C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE USBLIBPRO
OBJECT MODULE PLACED IN .\bin\UsbLibPro.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\UsbLibPro.c BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\UsbLibPro.lst) TABS(2
                    -) OBJECT(.\bin\UsbLibPro.obj)

line level    source

   1          #include "platform.h"
   2          
   3          
   4          void usb_video_class_function();
   5          unsigned char usbGetStatus();
   6          unsigned char usbClearFeature();
   7          unsigned char usbSetFeature();
   8          unsigned char usbSetAddress();
   9          unsigned char usbGetDescriptor();
  10          unsigned char usbGetConfig();
  11          unsigned char usbSetConfig();
  12          unsigned char usbGetInterface();
  13          unsigned char usbSetInterface();
  14          
  15          
  16          void controlCMD()
  17          {
  18   1        unsigned char x;
  19   1        x = ctrlFIFORead(CTRL_Buffer);
  20   1        
  21   1        if( x == TRUE ){
  22   2          if((CTRL_Buffer[0]==0x21) || (CTRL_Buffer[0]==0xA1)){
  23   3            usb_video_class_function();
  24   3          } else {
  25   3            
  26   3            switch(CTRL_Buffer[1]){
  27   4              case BR_GET_STATUS:
  28   4                x = usbGetStatus();
  29   4                break;
  30   4              case BR_CLEAR_FEATURE:
  31   4                x = usbClearFeature();
  32   4                //XBYTE[0xFC34] = 0x21;
  33   4                break;
  34   4              case BR_SET_FEATURE:
  35   4                x = usbSetFeature();
  36   4                break;
  37   4              case BR_SET_ADDRESS:
  38   4                x = usbSetAddress();
  39   4                break;
  40   4              case BR_GET_DESCRIPTOR:
  41   4                x = usbGetDescriptor();
  42   4                break;
  43   4              case BR_GET_CONFIGURATION:
  44   4                x = usbGetConfig();
  45   4                break;
  46   4              case BR_SET_CONFIGURATION:
  47   4                x = usbSetConfig();
  48   4                break;
  49   4              case BR_GET_INTERFACE:
  50   4                x = usbGetInterface();
  51   4                break;
  52   4              case BR_SET_INTERFACE:
  53   4                x = usbSetInterface();
  54   4                break;
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 2   

  55   4              default:
  56   4                x = FALSE;
  57   4                break;
  58   4            }
  59   3          }
  60   2        }
  61   1      }
  62          
  63          
  64          
  65          unsigned char usbGetStatus()
  66          {
  67   1        unsigned char x;
  68   1      
  69   1        // Check the Request integrity:
  70   1        // wLength must be 2 (LSB CTRL_Buffer[6], MSB CTRL_Buffer[7])
  71   1        // wValue must be 0 (LSB CTRL_Buffer[2], MSB CTRL_Buffer[3])
  72   1        if( (CTRL_Buffer[6] != 2) || (CTRL_Buffer[7] != 0) || (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) ) {
  73   2          return USB_STALL;
  74   2        }
  75   1      
  76   1        switch( CTRL_Buffer[0] ) {
  77   2          case 0x80:                // Device Status
  78   2            // Check wIndex (LSB CTRL_Buffer[4], MSB CTRL_Buffer[5])
  79   2              if( (CTRL_Buffer[4] == 0) && (CTRL_Buffer[5] == 0) ) {  // if wIndex == 0
  80   3                  // BUG: Not assigned x value will be returned
  81   3                  // Should be:  x = ((XBYTE[DEV_CTRL] >> 1) & 0x02) | DEV_CFG_SELF_PWRED; (or x = ((XBYTE[DEV_CTRL] >
             -> 1) & 0x02) | DEV_CFG_BUS_PWRED;)
  82   3                  // definitions:
  83   3                  // ((XBYTE[DEV_CTRL] >> 1) & 0x02)   - return the device Remote Wake up Enabled flag in bit 1 
  84   3                  // #define DEV_CFG_BUS_PWRED  (0x00)
  85   3                  // #define DEV_CFG_SELF_PWRED (0x01)
  86   3              } else {                                                // if wIndex != 0
  87   3                  return USB_STALL;
  88   3              }
  89   2              break;
  90   2          case 0x81:                // Interface status
  91   2              x = 0x00; // Always return 0
  92   2              break;
  93   2          case 0x82:                // Endpoint status
  94   2              // Check wIndex (LSB CTRL_Buffer[4], MSB CTRL_Buffer[5])
  95   2              if( CTRL_Buffer[5] != 0 ) {   // if wIndex MSB != 0
  96   3                  return USB_STALL;
  97   3              }
  98   2              switch( CTRL_Buffer[4] ) {    // LSB of wIndex specify EP
  99   3              case 0x00:  // Control EP
 100   3                  x = XBYTE[EP0_CTRL];
 101   3                  break;
 102   3              case 0x01:  // EP1 (OUT endpoint)
 103   3                  x = XBYTE[EP1_CTRL];
 104   3                  break;
 105   3              case 0x82:  // EP2 (IN Endpoint)
 106   3                  x = XBYTE[EP2_CTRL];
 107   3                  break;
 108   3              default:
 109   3                  return USB_STALL;
 110   3              }
 111   2      
 112   2              if( x & 0x02 ) {  // Check Endpoint Stall flag (bit 1)
 113   3                  x = 0x01;     // Set HALT Flag in the returned value if EP is Stalled
 114   3              } else {
 115   3                  x = 0x00;     // Do Not Set HALT Flag in the returned value if EP is Not Stalled
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 3   

 116   3              }
 117   2              break;
 118   2      
 119   2          default:
 120   2              return USB_STALL;
 121   2          }
 122   1      
 123   1          XBYTE[CONTROL_FIFO] = x;    // Put the result to EP0 FIFO (LSB of the returned STATUS)
 124   1          XBYTE[CONTROL_FIFO+1] = 0;  // Put 0 byte to EP0 FIFO (MSB of the returned STATUS)
 125   1          XBYTE[EP0_CTRL] |= 0x01;    // Set Endpoint Done flag to transfer the data
 126   1          
 127   1        return USB_DONE;
 128   1      }
 129          
 130          unsigned char usbClearFeature()
 131          {
 132   1        if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) ) {
 133   2              return USB_STALL;
 134   2        }
 135   1        
 136   1        switch( CTRL_Buffer[0] ) {
 137   2          case BMR_REC_DEVICE:                                //  Device status
 138   2              if( (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) ) {
 139   3                  return USB_STALL;
 140   3              }
 141   2      
 142   2              if( CTRL_Buffer[2] == FTR_DEVICE_REMOTE_WAKEUP ) {
 143   3                  //  RemoteWakeup = 0;
 144   3              } else {
 145   3                  return USB_STALL;
 146   3              }
 147   2              break;
 148   2      
 149   2          case BMR_REC_INTERFACE:                             //  Interface status
 150   2              return USB_STALL;
 151   2      
 152   2          case BMR_REC_ENDPOINT:                              //  Endpoint status
 153   2              if( CTRL_Buffer[2] == FTR_ENDPOINT_HALT ) {     //  Feature selector is endpoint_halt
 154   3                  if( CTRL_Buffer[5] != 0 ) {
 155   4                      return USB_STALL;
 156   4                  }
 157   3      
 158   3                  switch( CTRL_Buffer[4] ) {
 159   4                    case 0x00:
 160   4                        XBYTE[EP0_CTRL] = 0x18;
 161   4                        break;
 162   4                    case 0x01:
 163   4                        XBYTE[EP1_CTRL] = 0x28;
 164   4                        XBYTE[ENP_TOG_CLR] = 0x02;
 165   4                        //  XBYTE[USB3_FIFO_FLUSH_CTRL] = 0x03;
 166   4                        break;
 167   4                    case 0x82:
 168   4                        XBYTE[EP2_CTRL] = 0x10;
 169   4                        XBYTE[ENP_TOG_CLR] = 0x04;
 170   4                        break;
 171   4                    default:
 172   4                        return USB_STALL;
 173   4                  }
 174   3              } else {
 175   3                  return USB_STALL;
 176   3              }
 177   2              break;
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 4   

 178   2          default:
 179   2              return USB_STALL;
 180   2          }
 181   1          return USB_DONE;
 182   1      }
 183          
 184          unsigned char usbSetFeature()
 185          {
 186   1        if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) ) {
 187   2          return USB_STALL;
 188   2        }
 189   1        
 190   1        switch( CTRL_Buffer[0] ) {
 191   2          case BMR_REC_DEVICE:                                //  Device status
 192   2              if( CTRL_Buffer[2] == FTR_DEVICE_REMOTE_WAKEUP ) {
 193   3                  //  RemoteWakeup = 1;
 194   3              } else if( CTRL_Buffer[2] == FTR_DEVICE_TEST_MODE ) {
 195   3                  if( (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] > 4) || (CTRL_Buffer[5] == 0) ) {
 196   4                      return USB_STALL;
 197   4                  }
 198   3                  
 199   3                  TEST_MODE = CTRL_Buffer[5] | 0x08;
 200   3              } else {
 201   3                  return USB_STALL;
 202   3              }
 203   2              break;
 204   2      
 205   2          case BMR_REC_INTERFACE:                             //  Interface status
 206   2              return USB_STALL;
 207   2              break;
 208   2          case BMR_REC_ENDPOINT:                  //  Endpoint status
 209   2            if( CTRL_Buffer[2] == FTR_ENDPOINT_HALT ) {
 210   3                  if( CTRL_Buffer[5] != 0 ) {
 211   4                      return USB_STALL;
 212   4                  }
 213   3      
 214   3                  switch( CTRL_Buffer[4] ) {
 215   4                    case 0x00:
 216   4                        XBYTE[EP0_CTRL] = 0x1A;
 217   4                        break;
 218   4                    case 0x01:
 219   4                        XBYTE[EP1_CTRL] = 0x2A;
 220   4                        break;
 221   4                    case 0x82:
 222   4                        XBYTE[EP2_CTRL] = 0x12;
 223   4                        break;
 224   4                    default:
 225   4                        return USB_STALL;
 226   4                  }
 227   3              } else {
 228   3                  return USB_STALL;
 229   3              }
 230   2              break;
 231   2          default:
 232   2              return USB_STALL;
 233   2          }
 234   1      
 235   1          return USB_DONE;
 236   1      }
 237          
 238          unsigned char usbSetAddress()
 239          {
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 5   

 240   1        if( (CTRL_Buffer[2] & 0x80) || (CTRL_Buffer[3] != 0) ||
 241   1                  (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) ||
 242   1                  (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) ) {
 243   2              return USB_STALL;
 244   2        }
 245   1        
 246   1        DEVICE0_ADDRESS = CTRL_Buffer[2];
 247   1        //Addressed = 1;  // Timer address_completion_wait
 248   1        
 249   1        XBYTE[EP0_CTRL] = 0x21;
 250   1        
 251   1        return USB_DONE;
 252   1      }
 253          
 254          unsigned char usbGetDescriptor()
 255          {
 256   1        unsigned char code *descp;
 257   1        unsigned short rlen;
 258   1        unsigned short cmd_len = 0;
 259   1        unsigned int  offset = 0;
 260   1        
 261   1        cmd_len = (CTRL_Buffer[7]*256 ) +  CTRL_Buffer[6];
 262   1      
 263   1        switch( CTRL_Buffer[3] ) {
 264   2      
 265   2          case DS_DEVICE:                     // Device Descriptor
 266   2              rlen = Ide_Dvc_Dlen;
 267   2              descp = Ide_Dvc_D;
 268   2              if( (CTRL_Buffer[6] < rlen) ) {
 269   3                  rlen = CTRL_Buffer[6];
 270   3              }
 271   2              ctrlFIFOWrite(rlen,descp);
 272   2          case DS_CONFIGURATION:              // Configuration Descriptor
 273   2              descp = UVC_Std_D;
 274   2              rlen = UVC_Std_D_len;
 275   2              if( (cmd_len < rlen) ) {
 276   3                  rlen = cmd_len;
 277   3              }
 278   2              ctrlFIFOWrite(rlen,descp);
 279   2              break;
 280   2          case DS_STRING:                     // String Descriptor
 281   2              switch( CTRL_Buffer[2] ) {
 282   3                case 0x00:    // LangID string
 283   3                    rlen = Ide_Str0_Dlen;
 284   3                    descp = Ide_Str0_D;
 285   3                    if( (CTRL_Buffer[6] < rlen) ) {
 286   4                        rlen = CTRL_Buffer[6];
 287   4                    }
 288   3                    ctrlFIFOWrite(rlen,descp);
 289   3                    break;
 290   3                case 0x01:
 291   3                    rlen = Ide_Str1_Dlen;
 292   3                    descp = Ide_Str1_D;
 293   3                    if( (CTRL_Buffer[6] < rlen) ) {
 294   4                        rlen = CTRL_Buffer[6];
 295   4                    }
 296   3                    ctrlFIFOWrite(rlen,descp);
 297   3                    break;
 298   3                case 0x02:
 299   3                    rlen = Ide_Str2_Dlen;
 300   3                    descp = Ide_Str2_D;
 301   3                    if( (CTRL_Buffer[6] < rlen) ) {
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 6   

 302   4                        rlen = CTRL_Buffer[6];
 303   4                    }
 304   3                    ctrlFIFOWrite(rlen,descp);
 305   3                    // XBYTE[ENP_IRE_STORE] |= 0x01;
 306   3                    break;
 307   3                case 0x03:
 308   3                    rlen = Ide_Str3_Dlen;
 309   3                    descp = Ide_Str3_D;
 310   3                    if( (CTRL_Buffer[6] < rlen) ) {
 311   4                        rlen = CTRL_Buffer[6];
 312   4                    }
 313   3                    ctrlFIFOWrite(rlen,descp);
 314   3                    //XBYTE[ENP_IRE_STORE] |= 0x01;
 315   3                    break;
 316   3                default:
 317   3                    return USB_STALL;
 318   3              }
 319   2              break;
 320   2          case DS_DEVICE_QUALIFIER:           // Device_Qualifier Descriptor
 321   2              rlen = Ide_Dvc_QF_Dlen;
 322   2              descp = Ide_Dvc_QF_D;
 323   2              if( (CTRL_Buffer[6] < rlen) ) {
 324   3                  rlen = CTRL_Buffer[6];
 325   3              }
 326   2              ctrlFIFOWrite(rlen,descp);
 327   2              break;
 328   2          case DS_INTERFACE_POWER:            // Interface Power Configuration
 329   2              return USB_STALL;
 330   2          default:
 331   2              return USB_STALL;
 332   2          }
 333   1          
 334   1          return USB_DONE;
 335   1      }
 336          
 337          unsigned char usbGetConfig()
 338          {
 339   1          if( (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) ||
 340   1                  (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) ||
 341   1                  (CTRL_Buffer[6] != 1) || (CTRL_Buffer[7] != 0) ) {
 342   2              return USB_STALL;
 343   2          }
 344   1      
 345   1          if( Configed ) {
 346   2              XBYTE[CONTROL_FIFO] = 0x01;
 347   2          } else {
 348   2              XBYTE[CONTROL_FIFO] = 0x00;
 349   2          }
 350   1      
 351   1          XBYTE[EP0_CTRL] |= 0x01;
 352   1      
 353   1          return USB_DONE;
 354   1      }
 355          
 356          unsigned char usbSetConfig()
 357          {
 358   1        XBYTE[EP1_CTRL] = 0x28;
 359   1        XBYTE[EP2_CTRL] = 0x10;
 360   1        XBYTE[EP0_CTRL] = 0x21;
 361   1      
 362   1        return USB_DONE;
 363   1      }
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 7   

 364          
 365          unsigned char usbGetInterface()
 366          {
 367   1          if( (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 1) || (CTRL_Buffer[7] != 0) )
             - {
 368   2              return USB_STALL;
 369   2          }
 370   1      
 371   1          if( Configed ) {
 372   2              XBYTE[CONTROL_FIFO] = 0x00;
 373   2              XBYTE[EP0_CTRL] |= 0x01;
 374   2      
 375   2              return USB_DONE;
 376   2          } else {
 377   2              return USB_STALL;
 378   2          }
 379   1      }
 380          
 381          unsigned char usbSetInterface()
 382          {
 383   1      /*  
 384   1        if((CTRL_Buffer[0] == 0x01) &&
 385   1          (CTRL_Buffer[1] == 0x0B) &&
 386   1          (CTRL_Buffer[2] == 0x07) &&  
 387   1          (CTRL_Buffer[3] == 0x00) &&
 388   1          (CTRL_Buffer[4] == 0x01) && 
 389   1          (CTRL_Buffer[5] == 0x00) &&
 390   1          (CTRL_Buffer[6] == 0x00) &&
 391   1          (CTRL_Buffer[7] == 0x00) 
 392   1        ){
 393   1            GLOBAL_test=1;  
 394   1            //printStr("START_OUT\n");
 395   1        }
 396   1      */
 397   1        XBYTE[EP0_CTRL] |= 0x21;
 398   1        
 399   1        return USB_DONE;
 400   1      }
 401          
 402          void usb_video_class_function()
 403          { 
 404   1        // wLength represents the size of the parameters which will be passed in the data stage
 405   1        // of the control transfer
 406   1        // Potential BUG: just LSB of the wLength is used here. If the parameters length will be
 407   1        // bigger than 255 bytes we will not able to process the request correctly
 408   1        unsigned char UAC_len, i; //wLength
 409   1        UAC_len = CTRL_Buffer[6];
 410   1        
 411   1        // Host to Device
 412   1        if((CTRL_Buffer[0] == 0x21)) {  // If SET Request addressed to Entity ID or Interface received.
 413   2          
 414   2          // Read the Request Parameters from the EP0 FIFO
 415   2          // Potential BUG: What if the parameters data are not ready yet? I think some wait timout need to be imp
             -lemented here
 416   2          if (XBYTE[EP0_CTRL+2]==UAC_len) { // If the amount of data in FIFO == wLength
 417   3            // Read out the Request Parameters to the SHARE_Buffer
 418   3            for (i=0; i<UAC_len; i++) {
 419   4              SHARE_Buffer[i] = XBYTE[CONTROL_FIFO+i];
 420   4            }
 421   3          }
 422   2          
 423   2          // If we have
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 8   

 424   2          // bRequest (Control Attribute ID)  = SET_CUR (Current Setting Attribute = 0x01 ) // CTRL_Buffer[1]
 425   2          // wValue (Control Selector )       = 0x0200 (Control Selector = 0x02 ) // LSB CTRL_Buffer[2], MSB CTRL_Buf
             -fer[3] // WHAT IS CONTROL 0x02 ????
 426   2          // wIndex (Entity ID, Interface )   = 0x0001 (Interface = 0x01, Entity ID = 0x00 for interface ) // LSB C
             -TRL_Buffer[4] - Interface, MSB CTRL_Buffer[5] - Entity ID
 427   2          // wLength ( lengths of the parameter block ) = 0x00A1 // LSB CTRL_Buffer[6], MSB CTRL_Buffer[7]
 428   2          if ((CTRL_Buffer[1] == 0x01) &&
 429   2              (CTRL_Buffer[2] == 0x00) && 
 430   2              (CTRL_Buffer[3] == 0x02) && 
 431   2              (CTRL_Buffer[4] == 0x01) &&
 432   2              (CTRL_Buffer[5] == 0x00) &&
 433   2              (CTRL_Buffer[6] == 0x1A) &&
 434   2              (CTRL_Buffer[7] == 0x00)){
 435   3                //GLOBAL_test = 1;
 436   3          }
 437   2          
 438   2          //???????????????????
 439   2          for (i=0; i<0xFE; i++) 
 440   2          {                 
 441   3          }//Delay for confirming the last data is already written to the register
 442   2              
 443   2          XBYTE[EP0_CTRL] |= 0x04;  //flush control pipe
 444   2          XBYTE[EP0_CTRL] = 0x21;   // Configure Endpoint 0: (bit5) - unmask "Packet of Data being received" interr
             -upt, (bit0) - set Endpoint Done flag
 445   2        }
 446   1        // Device to Host
 447   1        else if((CTRL_Buffer[0] == 0xA1)) { // If GET Request addressed to Entity ID or Interface received
 448   2          
 449   2          if(UAC_len ==0) {
 450   3            // if the parameters data length is 0 (so no data stage expected in the request transfer )
 451   3            // Finalyze request transfer
 452   3            XBYTE[EP0_CTRL] = 0x21;
 453   3            // XBYTE[EP0_CTRL] = 0x21; // Do twice???
 454   3          }
 455   2          
 456   2          
 457   2          // GET_INFO (0x86) Request Processing
 458   2          // The GET_INFO request queries the capabilities and status of the specified control. 
 459   2          // When issuing this request, the wLength field shall always be set to a value of 1 byte. 
 460   2          // The result returned is a bit mask reporting the capabilities of the control. The bits are defined as:
 461   2          // ****************************************************************************************
 462   2          //  Bit field * Description                       * Bit State
 463   2          // ****************************************************************************************
 464   2          //        *                             *
 465   2          //  D0      * 1=Supports GET value requests             * Capability
 466   2          // **************************************************************************************** 
 467   2          //  D1      * 1=Supports SET value requests             * Capability
 468   2          // **************************************************************************************** 
 469   2          //  D2      * 1=Disabled due to automatic mode            * State
 470   2          //        * (under device control)                  *
 471   2          // **************************************************************************************** 
 472   2          //  D3      * 1= Autoupdate Control                   * Capability
 473   2          //        * (see section 2.4.2.2 "Status Interrupt Endpoint")   *
 474   2          // ****************************************************************************************
 475   2          //  D4      * 1= Asynchronous Control                 * Capability
 476   2          //        * (see sections 2.4.2.2 "Status Interrupt Endpoint"   *
 477   2          //        * and 2.4.4, ?ontrol Transfer and Request Processing? *
 478   2          // **************************************************************************************** 
 479   2          //  D7..D5    * Reserved (Set to 0)                   * --
 480   2          // ****************************************************************************************
 481   2          if(CTRL_Buffer[1] == USB_UVC_GET_INFO) {
 482   3            
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 9   

 483   3            if((CTRL_Buffer[3] == 0x03) || (CTRL_Buffer[3] == 0x06) || (CTRL_Buffer[3] == 0x08)||
 484   3                ((CTRL_Buffer[3] == 0x09) && (CTRL_Buffer[5] == 0x02))|| (CTRL_Buffer[3] == 0x01) || (CTRL_Buffer[
             -3] == 0x05) ||
 485   3                (CTRL_Buffer[3] == 0x10) || (CTRL_Buffer[3] == 0x18) || ((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5
             -] == 0x02))||
 486   3                ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02)) || ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer
             -[5] == 0x04))) {
 487   4              SHARE_Buffer[0]=0x03;
 488   4              ctrlFIFOWrite(1, SHARE_Buffer);
 489   4              XBYTE[EP0_CTRL] = 0x21;
 490   4            }
 491   3            /*else if( (CTRL_Buffer[3] == 0x02) ){
 492   3              SHARE_Buffer[0]=0x03;
 493   3              ctrlFIFOWrite(1,SHARE_Buffer);        
 494   3            }*/
 495   3            else if(((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01)) || (CTRL_Buffer[3] == 0x0A)){
 496   4              SHARE_Buffer[0]=0x0F;
 497   4              ctrlFIFOWrite(1, SHARE_Buffer); 
 498   4              XBYTE[EP0_CTRL] = 0x21;
 499   4            }
 500   3            else if((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x04)) {
 501   4              SHARE_Buffer[0]=0x01;
 502   4              ctrlFIFOWrite(1, SHARE_Buffer); 
 503   4              XBYTE[EP0_CTRL] = 0x21;
 504   4            }
 505   3            else {
 506   4              XBYTE[EP0_CTRL] = 0x23; 
 507   4            }
 508   3          } // GET INFO
 509   2          
 510   2          // GET_MIN (0x82)
 511   2          if(CTRL_Buffer[1] == USB_UVC_GET_MIN) {
 512   3            if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) {
 513   4              SHARE_Buffer[0]=0x00;
 514   4              SHARE_Buffer[1]=0x00;
 515   4              SHARE_Buffer[2]=0x00;
 516   4              SHARE_Buffer[3]=0x00;
 517   4              ctrlFIFOWrite(4, SHARE_Buffer);
 518   4              XBYTE[EP0_CTRL] = 0x21;
 519   4            }
 520   3            else if(((CTRL_Buffer[3] == 0x03) || 
 521   3              (CTRL_Buffer[3] == 0x07) || 
 522   3              (CTRL_Buffer[3] == 0x08) || 
 523   3              (CTRL_Buffer[3] == 0x01)) &&
 524   3              (CTRL_Buffer[5] == 0x02)){
 525   4              SHARE_Buffer[0]=0x00;
 526   4              SHARE_Buffer[1]=0x00;
 527   4              ctrlFIFOWrite(2, SHARE_Buffer); 
 528   4              XBYTE[EP0_CTRL] = 0x21;
 529   4            }
 530   3            else if(((CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x01)) && (CTRL_Buffer[6] == 0x01)) {
 531   4              SHARE_Buffer[0]=0x00;
 532   4              ctrlFIFOWrite(1,SHARE_Buffer); 
 533   4              XBYTE[EP0_CTRL] = 0x21;
 534   4            }
 535   3            else if((CTRL_Buffer[3] == 0x04)){
 536   4              if((CTRL_Buffer[5] == 0x01)){
 537   5                SHARE_Buffer[0]=0x08;
 538   5                SHARE_Buffer[1]=0x00;
 539   5                SHARE_Buffer[2]=0x00;
 540   5                SHARE_Buffer[3]=0x00;
 541   5                ctrlFIFOWrite(4,SHARE_Buffer);
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 10  

 542   5                XBYTE[EP0_CTRL] = 0x21;
 543   5              }
 544   4              else{
 545   5                SHARE_Buffer[0]=0x20;
 546   5                SHARE_Buffer[1]=0x00;
 547   5                ctrlFIFOWrite(2,SHARE_Buffer);     
 548   5                XBYTE[EP0_CTRL] = 0x21;   
 549   5              }
 550   4            }
 551   3            else if((CTRL_Buffer[3] == 0x02)){
 552   4              if((CTRL_Buffer[2] == 0x00)) {
 553   5                SHARE_Buffer[0]=0xF6;
 554   5                SHARE_Buffer[1]=0xFF;
 555   5                ctrlFIFOWrite(2,SHARE_Buffer);
 556   5                XBYTE[EP0_CTRL] = 0x21;
 557   5              }
 558   4              else{
 559   5                SHARE_Buffer[0]=0x00;
 560   5                SHARE_Buffer[1]=0xE5;
 561   5                ctrlFIFOWrite(2,SHARE_Buffer);
 562   5                XBYTE[EP0_CTRL] = 0x21;
 563   5              }
 564   4            }
 565   3            else if((CTRL_Buffer[3] == 0x06)){
 566   4              SHARE_Buffer[0]=0xFB;
 567   4              SHARE_Buffer[1]=0xFF;
 568   4              ctrlFIFOWrite(2,SHARE_Buffer);
 569   4              XBYTE[EP0_CTRL] = 0x21;
 570   4            }
 571   3            else if((CTRL_Buffer[3] == 0x09)){
 572   4              SHARE_Buffer[0]=0x64;
 573   4              SHARE_Buffer[1]=0x00;
 574   4              ctrlFIFOWrite(2,SHARE_Buffer);
 575   4              XBYTE[EP0_CTRL] = 0x21;
 576   4            }
 577   3            else if((CTRL_Buffer[3] == 0x0A)){
 578   4              SHARE_Buffer[0]=0xF0;
 579   4              SHARE_Buffer[1]=0x0A;
 580   4              ctrlFIFOWrite(2,SHARE_Buffer);
 581   4              XBYTE[EP0_CTRL] = 0x21;
 582   4            }
 583   3            else if((CTRL_Buffer[3] == 0x0A)){
 584   4              SHARE_Buffer[0]=0xF0;
 585   4              SHARE_Buffer[1]=0x0A;
 586   4              ctrlFIFOWrite(2,SHARE_Buffer);
 587   4              XBYTE[EP0_CTRL] = 0x21;
 588   4            }
 589   3            else if((CTRL_Buffer[3] == 0x01) &&
 590   3              (CTRL_Buffer[4] == 0x01) && 
 591   3              (CTRL_Buffer[5] == 0x00) && 
 592   3              (CTRL_Buffer[6] == 0x1A)){
 593   4                SHARE_Buffer[0]=0x00;
 594   4                SHARE_Buffer[1]=0x00;
 595   4                SHARE_Buffer[2]=0x01;
 596   4                SHARE_Buffer[3]=0x03;
 597   4                SHARE_Buffer[4]=0x15;
 598   4                SHARE_Buffer[5]=0x16;
 599   4                SHARE_Buffer[6]=0x05;
 600   4                SHARE_Buffer[7]=0x00;
 601   4                SHARE_Buffer[8]=0x00;
 602   4                SHARE_Buffer[9]=0x00;
 603   4                SHARE_Buffer[10]=0x00;
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 11  

 604   4                SHARE_Buffer[11]=0x00;
 605   4                SHARE_Buffer[12]=0x00;
 606   4                SHARE_Buffer[13]=0x00;
 607   4                SHARE_Buffer[14]=0x00;
 608   4                SHARE_Buffer[15]=0x00;
 609   4                SHARE_Buffer[16]=0x00;
 610   4                SHARE_Buffer[17]=0x00;
 611   4                SHARE_Buffer[18]=0x00;
 612   4                SHARE_Buffer[19]=0x58;
 613   4                SHARE_Buffer[20]=0x02;
 614   4                SHARE_Buffer[21]=0x00;
 615   4                SHARE_Buffer[22]=0x00;
 616   4                SHARE_Buffer[23]=0x0C;
 617   4                SHARE_Buffer[24]=0x00;
 618   4                SHARE_Buffer[25]=0x00;
 619   4                ctrlFIFOWrite(26,SHARE_Buffer); 
 620   4            }
 621   3          } // GET_MIN
 622   2          
 623   2          // GET_MAX (0x83)
 624   2          if(CTRL_Buffer[1] == USB_UVC_GET_MAX) {
 625   3            if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) {
 626   4              SHARE_Buffer[0]=0xFF;
 627   4              SHARE_Buffer[1]=0xFF;
 628   4              SHARE_Buffer[2]=0xFF;
 629   4              SHARE_Buffer[3]=0xFF;
 630   4              ctrlFIFOWrite(4,SHARE_Buffer);
 631   4              XBYTE[EP0_CTRL] = 0x21;
 632   4            }
 633   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02) && (CTRL_Buffer[3] == 0x07) )){
 634   4              SHARE_Buffer[0]=0x0A;
 635   4              SHARE_Buffer[1]=0x00;
 636   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 637   4              XBYTE[EP0_CTRL] = 0x21;
 638   4            }
 639   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && ((CTRL_Buffer[3] == 0x02 ||
 640   3            (CTRL_Buffer[3] == 0x08)))){
 641   4              SHARE_Buffer[0]=0x0A;
 642   4              SHARE_Buffer[1]=0x00;
 643   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 644   4              XBYTE[EP0_CTRL] = 0x21;
 645   4            }
 646   3            else if((CTRL_Buffer[3] == 0x04)){
 647   4              if((CTRL_Buffer[5] == 0x01)){
 648   5                SHARE_Buffer[0]=0x00;
 649   5                SHARE_Buffer[1]=0x40;
 650   5                SHARE_Buffer[2]=0x00;
 651   5                SHARE_Buffer[3]=0x00;
 652   5                ctrlFIFOWrite(4,SHARE_Buffer); 
 653   5                XBYTE[EP0_CTRL] = 0x21;
 654   5              }
 655   4              else if((CTRL_Buffer[5] == 0x02)){
 656   5                SHARE_Buffer[0]=0x30;
 657   5                SHARE_Buffer[1]=0x00;
 658   5                ctrlFIFOWrite(2,SHARE_Buffer);
 659   5                XBYTE[EP0_CTRL] = 0x21;
 660   5              }
 661   4            }
 662   3            else if((CTRL_Buffer[3] == 0x03)){
 663   4              SHARE_Buffer[0]=0x14;
 664   4              SHARE_Buffer[1]=0x00;
 665   4              ctrlFIFOWrite(2,SHARE_Buffer); 
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 12  

 666   4              XBYTE[EP0_CTRL] = 0x21;
 667   4            }
 668   3            else if((CTRL_Buffer[3] == 0x06)){
 669   4              SHARE_Buffer[0]=0x05;
 670   4              SHARE_Buffer[1]=0x00;
 671   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 672   4              XBYTE[EP0_CTRL] = 0x21;
 673   4            }
 674   3            else if((CTRL_Buffer[3] == 0x09)){
 675   4              SHARE_Buffer[0]=0xC8;
 676   4              SHARE_Buffer[1]=0x00;
 677   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 678   4              XBYTE[EP0_CTRL] = 0x21;
 679   4            }
 680   3            else if((CTRL_Buffer[3] == 0x0A)){
 681   4              SHARE_Buffer[0]=0x64;
 682   4              SHARE_Buffer[1]=0x19;
 683   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 684   4              XBYTE[EP0_CTRL] = 0x21;
 685   4            }
 686   3            else if((CTRL_Buffer[3] == 0x01)){
 687   4              if((CTRL_Buffer[5] == 0x02)){
 688   5                SHARE_Buffer[0]=0x01;
 689   5                SHARE_Buffer[1]=0x00;
 690   5                ctrlFIFOWrite(2,SHARE_Buffer);  
 691   5                XBYTE[EP0_CTRL] = 0x21;
 692   5              }
 693   4              else if( (CTRL_Buffer[4] == 0x01) && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x1A)){
 694   5                SHARE_Buffer[0]=0x00;
 695   5                SHARE_Buffer[1]=0x00;
 696   5                SHARE_Buffer[2]=0x01;
 697   5                SHARE_Buffer[3]=0x03;
 698   5                SHARE_Buffer[4]=0x15;
 699   5                SHARE_Buffer[5]=0x16;
 700   5                SHARE_Buffer[6]=0x05;
 701   5                SHARE_Buffer[7]=0x00;
 702   5                SHARE_Buffer[8]=0x00;
 703   5                SHARE_Buffer[9]=0x00;
 704   5                SHARE_Buffer[10]=0x00;
 705   5                SHARE_Buffer[11]=0x00;
 706   5                SHARE_Buffer[12]=0x00;
 707   5                SHARE_Buffer[13]=0x00;
 708   5                SHARE_Buffer[14]=0x00;
 709   5                SHARE_Buffer[15]=0x00;
 710   5                SHARE_Buffer[16]=0x00;
 711   5                SHARE_Buffer[17]=0x00;
 712   5                SHARE_Buffer[18]=0x00;
 713   5                SHARE_Buffer[19]=0x58;
 714   5                SHARE_Buffer[20]=0x02;
 715   5                SHARE_Buffer[21]=0x00;
 716   5                SHARE_Buffer[22]=0x00;
 717   5                SHARE_Buffer[23]=0x0C;
 718   5                SHARE_Buffer[24]=0x00;
 719   5                SHARE_Buffer[25]=0x00;
 720   5                ctrlFIFOWrite(26,SHARE_Buffer); 
 721   5              }
 722   4              else{
 723   5                SHARE_Buffer[0]=0xFF;
 724   5                ctrlFIFOWrite(1,SHARE_Buffer);
 725   5                XBYTE[EP0_CTRL] = 0x21;
 726   5              }
 727   4            }
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 13  

 728   3            else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02)){
 729   4              SHARE_Buffer[0]=0x02;
 730   4              ctrlFIFOWrite(1,SHARE_Buffer); 
 731   4              XBYTE[EP0_CTRL] = 0x21;
 732   4            }
 733   3            else if((CTRL_Buffer[2] == 0x01)){
 734   4              SHARE_Buffer[0]=0x00;
 735   4              SHARE_Buffer[1]=0x15;
 736   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 737   4              XBYTE[EP0_CTRL] = 0x21;
 738   4            }
 739   3          } // GET MAX
 740   2          
 741   2          // GET_RES
 742   2          if(CTRL_Buffer[1] == USB_UVC_GET_RES) {
 743   3            if (((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) || ((CTRL_Buffer[5] == 0x01) && (CTRL_Buffer
             -[6] == 0x04))) {
 744   4              SHARE_Buffer[0]=0x01;
 745   4              SHARE_Buffer[1]=0x00;
 746   4              SHARE_Buffer[2]=0x00;
 747   4              SHARE_Buffer[3]=0x00;
 748   4              ctrlFIFOWrite(4,SHARE_Buffer);
 749   4              XBYTE[EP0_CTRL] = 0x21;
 750   4            }
 751   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && (CTRL_Buffer[6] == 0x02)){
 752   4              SHARE_Buffer[0]=0x01;
 753   4              SHARE_Buffer[1]=0x00;
 754   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 755   4              XBYTE[EP0_CTRL] = 0x21;
 756   4            }
 757   3            else if((CTRL_Buffer[3] == 0x01) || ((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02))){
 758   4              SHARE_Buffer[0]=0x01;
 759   4              ctrlFIFOWrite(1,SHARE_Buffer);
 760   4              XBYTE[EP0_CTRL] = 0x21; 
 761   4            }
 762   3            else if((CTRL_Buffer[2] == 0x01)){
 763   4              SHARE_Buffer[0]=0x00;
 764   4              SHARE_Buffer[1]=0x01;
 765   4              ctrlFIFOWrite(2,SHARE_Buffer);
 766   4              XBYTE[EP0_CTRL] = 0x21; 
 767   4            }
 768   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01)) && (CTRL_Buffer[6] == 0x02)){
 769   4              SHARE_Buffer[0]=0x01;
 770   4              SHARE_Buffer[1]=0x00;
 771   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 772   4              XBYTE[EP0_CTRL] = 0x21;
 773   4            }
 774   3          } // GET RES
 775   2          
 776   2          // GET_DEF
 777   2          if(CTRL_Buffer[1] == USB_UVC_GET_DEF) {
 778   3            if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) {
 779   4              SHARE_Buffer[0]=0x00;
 780   4              SHARE_Buffer[1]=0x00;
 781   4              SHARE_Buffer[2]=0x00;
 782   4              SHARE_Buffer[3]=0x00;
 783   4              ctrlFIFOWrite(4,SHARE_Buffer);
 784   4              XBYTE[EP0_CTRL] = 0x21;
 785   4            }
 786   3            else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01)){
 787   4              SHARE_Buffer[0]=0x00;
 788   4              SHARE_Buffer[1]=0x02;
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 14  

 789   4              SHARE_Buffer[2]=0x00;
 790   4              SHARE_Buffer[3]=0x00;
 791   4              ctrlFIFOWrite(4,SHARE_Buffer); 
 792   4              XBYTE[EP0_CTRL] = 0x21;
 793   4            }
 794   3            else if((CTRL_Buffer[3] == 0x02)){
 795   4              SHARE_Buffer[0]=0x02;
 796   4              SHARE_Buffer[1]=0x00;
 797   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 798   4              XBYTE[EP0_CTRL] = 0x21;
 799   4            }
 800   3            else if((CTRL_Buffer[3] == 0x03)){
 801   4              SHARE_Buffer[0]=0x0A;
 802   4              SHARE_Buffer[1]=0x00;
 803   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 804   4              XBYTE[EP0_CTRL] = 0x21;
 805   4            }
 806   3            else if((CTRL_Buffer[3] == 0x06)){
 807   4              SHARE_Buffer[0]=0x00;
 808   4              SHARE_Buffer[1]=0x00;
 809   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 810   4              XBYTE[EP0_CTRL] = 0x21;
 811   4            }
 812   3            else if(((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x02))){
 813   4              SHARE_Buffer[0]=0x04;
 814   4              SHARE_Buffer[1]=0x00;
 815   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 816   4              XBYTE[EP0_CTRL] = 0x21;
 817   4            }
 818   3            else if((CTRL_Buffer[3] == 0x08)){
 819   4              SHARE_Buffer[0]=0x04;
 820   4              SHARE_Buffer[1]=0x00;
 821   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 822   4              XBYTE[EP0_CTRL] = 0x21;
 823   4            } 
 824   3            else if((CTRL_Buffer[3] == 0x09)){
 825   4              SHARE_Buffer[0]=0x82;
 826   4              SHARE_Buffer[1]=0x00; 
 827   4              ctrlFIFOWrite(2,SHARE_Buffer);
 828   4              XBYTE[EP0_CTRL] = 0x21; 
 829   4            }
 830   3            else if((CTRL_Buffer[3] == 0x0A)){
 831   4              SHARE_Buffer[0]=0x64;
 832   4              SHARE_Buffer[1]=0x19;
 833   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 834   4              XBYTE[EP0_CTRL] = 0x21;
 835   4            }
 836   3            else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x02)){
 837   4              SHARE_Buffer[0]=0x01;
 838   4              SHARE_Buffer[1]=0x00;
 839   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 840   4              XBYTE[EP0_CTRL] = 0x21;
 841   4            }
 842   3            else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02)){
 843   4              SHARE_Buffer[0]=0x22;
 844   4              SHARE_Buffer[1]=0x00;
 845   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 846   4              XBYTE[EP0_CTRL] = 0x21;
 847   4            }
 848   3            else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02)){
 849   4              SHARE_Buffer[0]=0x02;
 850   4              ctrlFIFOWrite(1,SHARE_Buffer);
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 15  

 851   4              XBYTE[EP0_CTRL] = 0x21; 
 852   4            }
 853   3            else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x04)){
 854   4              SHARE_Buffer[0]=0x00;
 855   4              ctrlFIFOWrite(1,SHARE_Buffer); 
 856   4              XBYTE[EP0_CTRL] = 0x21;
 857   4            }
 858   3          } // GET DEF
 859   2          
 860   2          // GET_CUR
 861   2          if((CTRL_Buffer[1] == USB_UVC_GET_CUR)) {
 862   3            if((CTRL_Buffer[3] == 0x02)) {
 863   4              if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x01)){
 864   5                SHARE_Buffer[0]=0x06;
 865   5                ctrlFIFOWrite(1,SHARE_Buffer);
 866   5                XBYTE[EP0_CTRL] = 0x21;
 867   5              }
 868   4              else if((CTRL_Buffer[4] == 0x02) && (CTRL_Buffer[5] == 0x02)){
 869   5                SHARE_Buffer[0]=0x00;
 870   5                SHARE_Buffer[1]=0x0B;
 871   5                ctrlFIFOWrite(2,SHARE_Buffer);
 872   5                XBYTE[EP0_CTRL] = 0x21;
 873   5              }
 874   4              else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)){
 875   5                SHARE_Buffer[0]=0x02;
 876   5                SHARE_Buffer[1]=0x00;
 877   5                ctrlFIFOWrite(2,SHARE_Buffer);
 878   5                XBYTE[EP0_CTRL] = 0x21;
 879   5              }
 880   4              else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01)){
 881   5                SHARE_Buffer[0]=0x08;
 882   5                ctrlFIFOWrite(1,SHARE_Buffer);
 883   5                XBYTE[EP0_CTRL] = 0x21;
 884   5              }
 885   4            }
 886   3            else if(CTRL_Buffer[3] == 0x01){
 887   4              if((CTRL_Buffer[4] == 0x02)){
 888   5                SHARE_Buffer[0]=0x00;
 889   5                ctrlFIFOWrite(1,SHARE_Buffer);
 890   5                XBYTE[EP0_CTRL] = 0x21;
 891   5              }
 892   4              else if((CTRL_Buffer[4] == 0x00)) {
 893   5                SHARE_Buffer[0]=0x01;
 894   5                SHARE_Buffer[1]=0x00;
 895   5                ctrlFIFOWrite(2,SHARE_Buffer);
 896   5                XBYTE[EP0_CTRL] = 0x21;
 897   5              }
 898   4              else if((CTRL_Buffer[4] == 0x01)) {
 899   5                if (test_flag == 0){
 900   6                  for(i = 0;i < 26;i++){
 901   7                    SHARE_Buffer[i]=0x00;
 902   7                  }
 903   6                  SHARE_Buffer[2]=0x01;
 904   6                  SHARE_Buffer[3]=0x01;
 905   6                  SHARE_Buffer[4]=0x15;
 906   6                  SHARE_Buffer[5]=0x16;
 907   6                  SHARE_Buffer[6]=0x05;
 908   6                  SHARE_Buffer[19]=0x60;
 909   6                  SHARE_Buffer[20]=0x09;
 910   6                  SHARE_Buffer[22]=0x80;
 911   6                  SHARE_Buffer[23]=0x0A;
 912   6                  ctrlFIFOWrite(26,SHARE_Buffer);
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 16  

 913   6                  XBYTE[EP0_CTRL] = 0x21;
 914   6                  test_flag = 1;
 915   6                }
 916   5                else{
 917   6                  for(i = 0;i < 26;i++)
 918   6                  {
 919   7                    SHARE_Buffer[i]=0x00;
 920   7                  }
 921   6                  SHARE_Buffer[2]=0x01;
 922   6                  SHARE_Buffer[3]=0x01;
 923   6                  SHARE_Buffer[4]=0x15;
 924   6                  SHARE_Buffer[5]=0x16;
 925   6                  SHARE_Buffer[6]=0x05;
 926   6                  SHARE_Buffer[19]=0x60;
 927   6                  SHARE_Buffer[20]=0x09;
 928   6                  SHARE_Buffer[22]=0x00;
 929   6                  SHARE_Buffer[23]=0x0C;
 930   6                  ctrlFIFOWrite(26,SHARE_Buffer);
 931   6                  XBYTE[EP0_CTRL] = 0x21;
 932   6                  //test_flag = 2;
 933   6                }
 934   5              }
 935   4            }
 936   3            else if(CTRL_Buffer[3] == 0x03){
 937   4              if(CTRL_Buffer[4] == 0x00){
 938   5                SHARE_Buffer[0]=0x0A;
 939   5                SHARE_Buffer[1]=0x00;
 940   5                ctrlFIFOWrite(2,SHARE_Buffer); 
 941   5                XBYTE[EP0_CTRL] = 0x21;
 942   5              }
 943   4              else if(CTRL_Buffer[4] == 0x01){
 944   5                if(test_flag == 1){
 945   6                  SHARE_Buffer[0]=0x01;
 946   6                  SHARE_Buffer[1]=0x01;
 947   6                  SHARE_Buffer[2]=0x00;
 948   6                  SHARE_Buffer[3]=0x00;
 949   6                  SHARE_Buffer[4]=0x06;
 950   6                  SHARE_Buffer[5]=0x09;
 951   6                  SHARE_Buffer[6]=0x00;
 952   6                  SHARE_Buffer[7]=0x80;
 953   6                  SHARE_Buffer[8]=0x0A;
 954   6                  SHARE_Buffer[9]=0x00;
 955   6                  SHARE_Buffer[10]=0x00;
 956   6                  ctrlFIFOWrite(11,SHARE_Buffer);
 957   6                  XBYTE[EP0_CTRL] = 0x21;
 958   6                  test_flag = 3;
 959   6                }
 960   5                else{
 961   6                  SHARE_Buffer[0]=0x01;
 962   6                  SHARE_Buffer[1]=0x01;
 963   6                  SHARE_Buffer[2]=0x00;
 964   6                  SHARE_Buffer[3]=0x00;
 965   6                  SHARE_Buffer[4]=0x06;
 966   6                  SHARE_Buffer[5]=0x09;
 967   6                  SHARE_Buffer[6]=0x00;
 968   6                  SHARE_Buffer[7]=0x00;
 969   6                  SHARE_Buffer[8]=0x0C;
 970   6                  SHARE_Buffer[9]=0x00;
 971   6                  SHARE_Buffer[10]=0x00;
 972   6                  ctrlFIFOWrite(11,SHARE_Buffer);
 973   6                  XBYTE[EP0_CTRL] = 0x21;
 974   6                }
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 17  

 975   5              }
 976   4            }
 977   3            else if(CTRL_Buffer[3] == 0x06){
 978   4              SHARE_Buffer[0]=0x00;
 979   4              SHARE_Buffer[1]=0x00;
 980   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 981   4              XBYTE[EP0_CTRL] = 0x21;
 982   4            }
 983   3            else if((CTRL_Buffer[3] == 0x07)){
 984   4              SHARE_Buffer[0]=0x04;
 985   4              SHARE_Buffer[1]=0x00;
 986   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 987   4              XBYTE[EP0_CTRL] = 0x21;
 988   4            }
 989   3            else if((CTRL_Buffer[3] == 0x08)){
 990   4              SHARE_Buffer[0]=0x04;
 991   4              SHARE_Buffer[1]=0x00;
 992   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 993   4              XBYTE[EP0_CTRL] = 0x21;
 994   4            }
 995   3            else if(CTRL_Buffer[3] == 0x09){
 996   4              SHARE_Buffer[0]=0x82;
 997   4              SHARE_Buffer[1]=0x00;
 998   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 999   4              XBYTE[EP0_CTRL] = 0x21;
1000   4            }
1001   3            else if(CTRL_Buffer[3] == 0x0A){
1002   4              SHARE_Buffer[0]=0x64;
1003   4              SHARE_Buffer[1]=0x19;
1004   4              ctrlFIFOWrite(2,SHARE_Buffer);
1005   4              XBYTE[EP0_CTRL] = 0x21; 
1006   4            }
1007   3            else if(CTRL_Buffer[3] == 0x0B){
1008   4              SHARE_Buffer[0]=0x01;
1009   4              ctrlFIFOWrite(1,SHARE_Buffer); 
1010   4              XBYTE[EP0_CTRL] = 0x21;
1011   4            }
1012   3            else if(CTRL_Buffer[3] == 0x04){
1013   4              SHARE_Buffer[0]=0x00;
1014   4              SHARE_Buffer[1]=0x02;
1015   4              SHARE_Buffer[2]=0x00;
1016   4              SHARE_Buffer[3]=0x00;
1017   4              ctrlFIFOWrite(4,SHARE_Buffer); 
1018   4              XBYTE[EP0_CTRL] = 0x21;
1019   4            }
1020   3            
1021   3          } // GET_CUR
1022   2          
1023   2          // GET_LEN
1024   2          if(CTRL_Buffer[1] == USB_UVC_GET_LEN) {
1025   3            if ((CTRL_Buffer[3] == 0x04) ||
1026   3                (CTRL_Buffer[3] == 0x05) || 
1027   3                (CTRL_Buffer[3] == 0x07) || 
1028   3                (CTRL_Buffer[3] == 0x10) ||
1029   3                (CTRL_Buffer[3] == 0x18)) {
1030   4              SHARE_Buffer[0]=0x04;
1031   4              SHARE_Buffer[1]=0x00;
1032   4              ctrlFIFOWrite(2,SHARE_Buffer);
1033   4              XBYTE[EP0_CTRL] = 0x21;
1034   4            }
1035   3            else if(CTRL_Buffer[3] == 0x01){
1036   4              SHARE_Buffer[0]=0x01;
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 18  

1037   4              SHARE_Buffer[1]=0x00;
1038   4              ctrlFIFOWrite(2,SHARE_Buffer);
1039   4              XBYTE[EP0_CTRL] = 0x21; 
1040   4            }
1041   3          }// GET_LEN
1042   2          
1043   2        }
1044   1      }
1045          
1046          
1047          
1048          
1049          /*
1050          //----------------Based on Prolific 20130805-------------------//
1051          
1052          // GET_STATUS
1053          unsigned char usbGetStatus(void)
1054          {
1055            
1056          unsigned char x;
1057          
1058              if( (CTRL_Buffer[6] != 2) || (CTRL_Buffer[7] != 0) || (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) )
1059              {
1060                  XBYTE[0xFC34] = 0x23;
1061                  return( FALSE );
1062              }
1063          
1064          
1065              switch( CTRL_Buffer[0] )
1066              {
1067                      // device status
1068                  case 0x80:
1069                      if( (CTRL_Buffer[4] == 0) && (CTRL_Buffer[5] == 0) )
1070                      {
1071                          /*
1072                          if( ! busPowered ) {
1073                            x = 0x01;
1074                          }
1075                          if( RemoteWakeup ) {
1076                            x = 0x00 | 0x02;
1077                          }
1078                          *-/
1079                          
1080                      }
1081                      else
1082                      {
1083                          XBYTE[0xFC34] = 0x23;          // endpoin stall
1084                          return( FALSE );
1085                      }
1086          
1087                      break;
1088          
1089                      // interface status
1090                  case 0x81:
1091                      x = 0x00;
1092                      break;
1093          
1094                      // endpoint status
1095                  case 0x82:
1096                      if( CTRL_Buffer[5] != 0 )
1097                      {
1098          
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 19  

1099                          XBYTE[0xFC34] = 0x23;
1100                          return( FALSE );
1101                      }
1102          
1103                      switch( CTRL_Buffer[4] )
1104                      {
1105                          case 0x00:
1106                              x = XBYTE[0xFC34];
1107                              break;
1108                          case 0x81:
1109                              x = XBYTE[0xFC3C];
1110                              break;
1111          
1112                          case 0x86:
1113                              x = XBYTE[0xFC64];
1114                              break;
1115          
1116                          default:
1117          
1118                              XBYTE[0xFC64] = 0x23;
1119                              return( FALSE );
1120                      }
1121                
1122                      if( x & 0x02 )
1123                      {
1124                
1125                          x = 0x01;
1126                      }
1127                      else
1128                      {
1129              
1130                          x = 0x00;
1131                      }
1132                      break;
1133          
1134                  default:
1135          
1136                XBYTE[0xFC34] = 0x23;
1137                      return( FALSE );
1138              }
1139          
1140              XBYTE[0xF000] = x;
1141              XBYTE[0xF000+1] = 0;
1142              XBYTE[0xFC34] |= 0x21; //done
1143          
1144              return( TRUE );
1145          }
1146          
1147          // CLEAR_FEATURE
1148          unsigned char usbClearFeature(void)
1149          {
1150              if( (CTRL_Buffer[3]) || (CTRL_Buffer[6]) || (CTRL_Buffer[7]) )
1151              {
1152                  XBYTE[0xFC34] = 0x23; 
1153                  return( FALSE );
1154              }
1155          
1156          
1157              switch( CTRL_Buffer[0] )
1158              {
1159          
1160                      // device status
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 20  

1161                  case 0x00:
1162                      if( (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) )
1163                      {
1164                          XBYTE[0xFC34] = 0x23;
1165                          return( FALSE );
1166                      }
1167          
1168                      if( CTRL_Buffer[2] == DEVICE_REMOTE_WAKEUP ){
1169                          //RemoteWakeup = 0;
1170                      }
1171                      else{
1172                          XBYTE[0xFC34] = 0x23;
1173                          return( FALSE );
1174                      }
1175                      break;
1176          
1177          
1178                      // interface status
1179                  case 0x01:
1180                      XBYTE[0xFC34] = 0x23;
1181                      return( FALSE );
1182          
1183          
1184                      // endpoint status
1185                  case 0x02:
1186                      if( CTRL_Buffer[2] == ENDPOINT_HALT )
1187                      {
1188          
1189                          if( CTRL_Buffer[5] != 0 )
1190                          {
1191                              XBYTE[0xFC34] = 0x23;
1192                              return( FALSE );
1193                          }
1194          
1195                          switch( CTRL_Buffer[4] )
1196                          {
1197                              case 0x00:
1198                                  XBYTE[0xFC34] = 0x18;
1199                                  break;
1200                              case 0x81:
1201                                  XBYTE[0xFC3C] = 0x00;
1202                                  XBYTE[0xFCB0] = 0x02;//ENP_TOG_CLR_L
1203          
1204                              case 0x86:
1205                                  XBYTE[0xFC64] = 0x00;
1206                                  XBYTE[0xFCB0] = 0x40;//ENP_TOG_CLR_L
1207                      
1208                                  break;                             
1209                              default:
1210                                  XBYTE[0xFC34] = 0x23;
1211                                  return( FALSE );
1212                          }
1213                      }
1214                      else
1215                      {
1216                          XBYTE[0xFC34] = 0x23;
1217                          return( FALSE );
1218                      }
1219          
1220                      break;
1221          
1222                  default:
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 21  

1223                      XBYTE[0xFC34] = 0x23;
1224                      return( FALSE );
1225              }
1226          
1227              XBYTE[0xFC34] = 0x21;
1228              return( TRUE );
1229          }
1230          
1231          // GET_CONFIGURATION
1232          unsigned char usbGetConfig(void)
1233          {
1234              if( (CTRL_Buffer[2] == 0) || (CTRL_Buffer[3] == 0) ||
1235                      (CTRL_Buffer[4] == 0) || (CTRL_Buffer[5] == 0) ||
1236                      (CTRL_Buffer[6] == 1) || (CTRL_Buffer[7] == 0) )
1237              {
1238                if( Configed ){
1239                    XBYTE[0xF000] = 0x01;
1240                }
1241                else
1242                {
1243                    XBYTE[0xF000] = 0x00;
1244                }
1245                XBYTE[0xFC34] |= 0x21;
1246              }
1247              else
1248              {
1249                XBYTE[0xFC34] = 0x23;
1250                  return( FALSE );    
1251              }
1252            
1253              return( TRUE );
1254          }
1255          
1256          
1257          // GET_DESCRIPTOR
1258          unsigned char usbGetDescriptor(void)
1259          {
1260          unsigned char code *descp;
1261          unsigned short rlen,i;
1262          unsigned short cmd_len = 0;
1263          unsigned int  offset = 0;
1264          
1265              cmd_len = (CTRL_Buffer[7]*256 ) +  CTRL_Buffer[6];
1266          
1267              switch( CTRL_Buffer[3] )
1268              {
1269          
1270                // Device Descriptor
1271                case 0x01:
1272          
1273                      rlen = Ide_Dvc_D[0];
1274                      descp = Ide_Dvc_D;
1275                      if( (cmd_len < rlen) )
1276                      {
1277                          rlen = CTRL_Buffer[6];
1278                      }
1279          
1280                      ctrlFIFOWrite(rlen,descp);
1281          
1282                      return( TRUE );
1283                
1284                // Configuration Descriptor & OTHER_SPEED_CONFIGURATION      
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 22  

1285                case 0x02:
1286                case 0x07:
1287              
1288                      rlen = Ide_Con_Dlen;
1289                      for(i=0; i<Ide_Con_Dlen; i++)
1290                      {
1291                         SHARE_Buffer[i] = *(Con_Std_Descp+i);
1292                      }
1293          
1294                      SHARE_Buffer[1] = CTRL_Buffer[3];
1295                       
1296                      if(cmd_len == 9)
1297                      {
1298                        ctrlFIFOWrite(rlen,SHARE_Buffer); 
1299                      }
1300                      else
1301                      { 
1302                        // Configuration Descriptor Interface Descriptor
1303              
1304                        rlen = UVC_Std_Dlen+Ide_Con_Dlen;
1305                        
1306                        if( (CTRL_Buffer[3] == 0x02)  )
1307                        {
1308                            for(i=0; i<UVC_Std_Dlen; i++)
1309                            {
1310              
1311                                SHARE_Buffer[i+Ide_Con_Dlen] = *(InterfaceEP_Descp+i);
1312                            }
1313                        }
1314                        else
1315                        {
1316                            for(i=0; i<UVC_Std_Dlen; i++)
1317                            {
1318                                SHARE_Buffer[i+Ide_Con_Dlen] = *(InterfaceEP_Oth_Descp+i);
1319                            } 
1320                        }
1321                              
1322                        if( (cmd_len < rlen) )
1323                        {
1324                            rlen = cmd_len;
1325                        }
1326                    
1327                        ctrlFIFOWrite(rlen,SHARE_Buffer);
1328                      }
1329                      
1330                      return( TRUE );
1331          
1332                      break;
1333          
1334                      // String Descriptor
1335                 case 0x03: // String Descriptor
1336                      switch( CTRL_Buffer[2] )
1337                      {
1338                          case 0x00:
1339                              rlen = Ide_Str0_Dlen;
1340                              descp = Ide_Str0_D;
1341                              if( (cmd_len < rlen) )
1342                              {
1343                                  rlen = cmd_len;
1344                              }
1345          
1346                              ctrlFIFOWrite(rlen,descp);
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 23  

1347                              return( TRUE );
1348                              break;
1349                          case 0x01:
1350                              rlen = Ide_Str1_Dlen;
1351                              descp = Ide_Str1_D;
1352                              if( (cmd_len < rlen) )
1353                              {
1354                                  rlen = cmd_len;
1355                              }
1356          
1357                              ctrlFIFOWrite(rlen,descp);
1358                              return( TRUE );
1359                              break;
1360                          case 0x02:
1361          
1362                              rlen = Ide_Str2_Dlen;
1363                              descp = Ide_Str2_D;
1364                              if( (cmd_len < rlen) )
1365                              {
1366                                  rlen = cmd_len;
1367                              }
1368          
1369                              ctrlFIFOWrite(rlen,descp);
1370                              return( TRUE );
1371                              break;
1372                          case 0x03:
1373                              rlen = Ide_Str2_Dlen;
1374                              descp = Ide_Str2_D;
1375                              if( (cmd_len < rlen) )
1376                              {
1377                                  rlen = cmd_len;
1378                              }
1379          
1380                              ctrlFIFOWrite(rlen,descp);
1381                              return( TRUE );
1382                              break;
1383          
1384                          default:
1385                              goto L_GetDescpStall;
1386                       }
1387              
1388                       break;
1389                 
1390                 // Device_Qualifier Descriptor
1391                 case 0x06: 
1392                      rlen = Ide_Dvc_QF_Dlen;
1393                      descp = Ide_Dvc_QF_D;
1394                      if( (cmd_len < rlen) )
1395                      {
1396                          rlen = cmd_len;
1397                      }
1398          
1399                      ctrlFIFOWrite(rlen,descp);
1400                      return( TRUE );
1401                      break;
1402                
1403                // Interface Power Configuration  
1404                case 0x08: 
1405                    goto L_GetDescpStall;
1406                    
1407                // BOS Descriptor    
1408                case 0x0F:
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 24  

1409                    rlen = 12;
1410                    descp = Ide_BOS_D;
1411                    if( (cmd_len < rlen) )
1412                    {
1413                        rlen = cmd_len;
1414                    }
1415                    ctrlFIFOWrite(rlen,descp);
1416                
1417                    return( TRUE );
1418                    break;  
1419                  break;
1420              
1421                default:
1422                  goto L_GetDescpStall;
1423              }
1424          
1425              return( TRUE );
1426          
1427          L_GetDescpStall:
1428              XBYTE[0xFC34] = 0x23;        // enpoint 0 stall
1429              return( FALSE );
1430          }
1431          
1432          
1433          // GET_INTERFACE
1434          
1435          unsigned char usbGetInterface(void)
1436          {
1437              if( (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 1) || (CTRL_Buffer[7] != 0) )
1438              {
1439                  XBYTE[0xFC34] = 0x23; 
1440                  return( FALSE );
1441              }
1442          
1443          
1444              if( Configed )
1445              {
1446                  XBYTE[0xF000] = SHARE_Buffer[0];
1447          
1448                  XBYTE[0xFC34] |= 0x21;
1449          
1450                  return( TRUE );
1451              }
1452              else
1453              {
1454                  return( FALSE );
1455              }
1456          }
1457          
1458          
1459          // SET_INTERFACE
1460          unsigned char usbSetInterface(void)
1461          {
1462            if(  (CTRL_Buffer[3] != 0) ||
1463                 (CTRL_Buffer[5] != 0) ||
1464                (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) ) 
1465            {
1466                XBYTE[0xFC34] = 0x23;     
1467                return( FALSE );
1468            }
1469            else 
1470            {
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 25  

1471              if( (CTRL_Buffer[0] == 0x01) && (CTRL_Buffer[1] == 0x0B) && (CTRL_Buffer[2] == 0x07) && 
1472                (CTRL_Buffer[3] == 0x00) && (CTRL_Buffer[4] == 0x01) && StartCIS1 == 1)
1473              {
1474              
1475                StartCIS1 = 0;
1476                StartCIS = 1; 
1477              }
1478          
1479              SHARE_Buffer[0] = CTRL_Buffer[2];
1480              XBYTE[0xFC64] = 0x10;
1481               
1482              XBYTE[0xFC34] |= 0x21;
1483              return( TRUE );
1484            }
1485          
1486            return( TRUE );
1487          }
1488          
1489          
1490          // SET_ADDRESS
1491          
1492          unsigned char usbSetAddress(void)
1493          {
1494              if( (CTRL_Buffer[2] & 0x80) || (CTRL_Buffer[3] != 0) ||
1495                      (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) ||
1496                      (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) )
1497              {
1498          
1499                  XBYTE[0xFC34] = 0x23;
1500                  return( FALSE );
1501              }
1502              else
1503              {
1504          
1505                  XBYTE[0xFC14] = CTRL_Buffer[2];    // Store the address to device address register
1506                  //Addressed = 1;
1507                  XBYTE[0xFC34] = 0x21;
1508                  return( TRUE );
1509          
1510              }
1511          }
1512          
1513          
1514          unsigned char usbSetConfig(void)
1515          {
1516          
1517              if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) || (CTRL_Buffer[6] != 0) |
             -| (CTRL_Buffer[7] != 0) )
1518              {
1519                  XBYTE[0xFC34] = 0x23;
1520                  return( FALSE );
1521              }
1522          
1523              switch( CTRL_Buffer[2] )
1524              {
1525                  case 0:
1526                      Configed = 0;
1527                      XBYTE[0xFC04] = 0x01;
1528          
1529                      break;
1530          
1531                  case 1:
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 26  

1532                      Configed = 1;
1533                      XBYTE[0xFC04] = 0x7F;
1534                      XBYTE[0xFC08] = 0x01;       // enable EP0 interrupt
1535                      XBYTE[0xFCB0] = 0x41;             // EP6 and EP0 toggle clear to DATA0
1536                      
1537                      break;
1538          
1539                  default:
1540                      return( FALSE );
1541              }
1542              XBYTE[0xFC64] = 0x10;
1543              XBYTE[0xFC34] |= 0x21;
1544          
1545              return( TRUE );
1546          
1547          }
1548          
1549          
1550          
1551          // SET_FEATURE
1552          
1553          unsigned char usbSetFeature(void)
1554          {
1555              if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) )
1556              {
1557                  XBYTE[0xFC34] = 0x23;
1558                  return( FALSE );
1559              }
1560          
1561              switch( CTRL_Buffer[0] )
1562              {
1563          
1564                  // device status
1565                  case 0x00:
1566                      if( CTRL_Buffer[2] == DEVICE_REMOTE_WAKEUP )
1567                      {     
1568                            RemoteWakeup = 1;
1569                      }
1570                      else if( CTRL_Buffer[2] == TEST_MODE )
1571                      {
1572                          if( (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] > 4) || (CTRL_Buffer[5] == 0) )
1573                          {
1574                              XBYTE[0xFC34] = 0x23;
1575                              return( FALSE );
1576                          }
1577          
1578                          XBYTE[0xFC10] = CTRL_Buffer[5] | 0x08;
1579                
1580                      }
1581                      else
1582                      {
1583                          XBYTE[0xFC34] = 0x23;
1584                          return( FALSE );
1585                      }
1586          
1587                      break;
1588          
1589          
1590                   // interface status
1591                  case 0x01:
1592                      XBYTE[0xFC34] = 0x23;
1593                      return( FALSE );
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 27  

1594                      
1595                  // endpoint status
1596                  case 0x02:
1597                      if( CTRL_Buffer[2] == ENDPOINT_HALT )
1598                      {
1599                          if( CTRL_Buffer[5] != 0 )
1600                          {
1601                              XBYTE[0xFC34] = 0x23;
1602                              return( FALSE );
1603                          }
1604          
1605                          switch( CTRL_Buffer[4] )
1606                          {
1607                              case 0x00:
1608                                  XBYTE[0xFC34] = 0x1A;           // EP0 flush FIFO, endpoint done
1609                              case 0x81:
1610                                  XBYTE[0xFC3C] = 0x12;           // EP1 stall
1611                                  break;
1612                              case 0x86:
1613                                  XBYTE[0xFC64] = 0x12;           // EP6 stall
1614                                  break;
1615          
1616                              default:
1617              
1618                                  XBYTE[0xFC34] = 0x23;
1619                                  return( FALSE );
1620                          }
1621                      }
1622                      else
1623                      {
1624              
1625                          XBYTE[0xFC34] = 0x23;
1626                          return( FALSE );
1627                      }
1628          
1629                      break;
1630          
1631                  default:
1632            
1633                      XBYTE[0xFC34] = 0x23;
1634                      return( FALSE );
1635              }
1636          
1637              XBYTE[0xFC34] |= 0x21;
1638              return( TRUE );
1639          }
1640          
1641          
1642          void usb_video_class_function(void)
1643          {
1644          unsigned char UAC_len,i;
1645          
1646          
1647            UAC_len = CTRL_Buffer[6];
1648          
1649            // Host to Device
1650            if((CTRL_Buffer[0] == 0x21)) 
1651            {
1652          
1653              if ((CTRL_Buffer[1] == 0x01) && (CTRL_Buffer[2] == 0x00) && (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[4]
             - == 0x01)
1654                   && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x1A) && (CTRL_Buffer[7] == 0x00))
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 28  

1655              {      
1656                 StartCIS1 = 1;
1657              }
1658             
1659            
1660              while(XBYTE[0xFC34+2] != UAC_len)
1661              {
1662                if( BusReset || (XBYTE[0xFC01] & 0x80 == 0))
1663                {
1664                  return ;
1665                }     
1666              }
1667          
1668          
1669              if (XBYTE[0xFC34+2] == UAC_len) 
1670              {
1671                    
1672                for (i=0; i<UAC_len; i++) 
1673                {
1674                   SHARE_Buffer[i] = XBYTE[0xF000+i];
1675              
1676                }
1677                
1678                if( (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x01))
1679                {
1680                  if( (SHARE_Buffer[0] != 0x01) && (SHARE_Buffer[0] != 0x08) )
1681                  {
1682                    XBYTE[0xFCB2] |= 0x01;
1683                    SHARE_Buffer[0] = 0x04;               
1684                    XBYTE[0xFC34] |= 0x04;   //flush FIFO
1685                    XBYTE[0xFC34] = 0x23;    // EP0 stall   
1686                  }
1687                  else
1688                  {     
1689                    XBYTE[0xFCB2] |= 0x01;
1690                    XBYTE[0xFC34] |= 0x04; //flush
1691                    XBYTE[0xFC34] = 0x21;         
1692                  }
1693                }
1694                else
1695                {
1696          
1697                  XBYTE[0xFCB2] |= 0x01;  //ENP_Interrupt_Restore_L
1698                  XBYTE[0xFC34] |= 0x04; //flush
1699                  XBYTE[0xFC34] = 0x21;       
1700                }     
1701          
1702              }
1703            } 
1704            
1705            // Device to Host
1706            else if((CTRL_Buffer[0] == 0xA1)) 
1707            {
1708              if(UAC_len ==0) {
1709                  XBYTE[0xFC34] = 0x21;
1710              }
1711            
1712              // GET_INFO
1713              if(CTRL_Buffer[1] == 0x86) 
1714              {
1715                if((CTRL_Buffer[3] == 0x03) || (CTRL_Buffer[3] == 0x06) || (CTRL_Buffer[3] == 0x08)||
1716                    ((CTRL_Buffer[3] == 0x09) && (CTRL_Buffer[5] == 0x02))|| (CTRL_Buffer[3] == 0x01) || (CTRL_Buffer[
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 29  

             -3] == 0x05) ||
1717                    (CTRL_Buffer[3] == 0x10) || (CTRL_Buffer[3] == 0x18) || ((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5
             -] == 0x02))||
1718                    ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02)) || ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer
             -[5] == 0x04))) 
1719                {
1720                  
1721                    SHARE_Buffer[0]=0x03;
1722                    ctrlFIFOWrite(1,SHARE_Buffer);          
1723                }
1724                else if( (CTRL_Buffer[3] == 0x02) )
1725                {
1726          
1727                    SHARE_Buffer[0]=0x03;
1728                    ctrlFIFOWrite(1,SHARE_Buffer);        
1729                }
1730          
1731                else if( ( (CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01) ) )
1732                {
1733              
1734                    SHARE_Buffer[0]=0x0F;
1735                    ctrlFIFOWrite(1,SHARE_Buffer); 
1736                }
1737                else if((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x04))
1738                {   
1739                    SHARE_Buffer[0]=0x01;
1740                    ctrlFIFOWrite(1,SHARE_Buffer); 
1741                }
1742                else
1743                {
1744                    XBYTE[0xFC34] = 0x23; 
1745                }
1746          
1747               
1748              }   //577 if
1749          
1750              
1751              //GET_MIN
1752              if(CTRL_Buffer[1] == 0x82) 
1753              {
1754                  if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) 
1755                  {
1756                  
1757                    SHARE_Buffer[0]=0x00;
1758                    SHARE_Buffer[1]=0x00;
1759                    SHARE_Buffer[2]=0x00;
1760                    SHARE_Buffer[3]=0x00;
1761                    ctrlFIFOWrite(4,SHARE_Buffer);
1762                  }
1763          
1764                  else if(((CTRL_Buffer[3] == 0x03) || (CTRL_Buffer[3] == 0x07) || (CTRL_Buffer[3] == 0x08) || (CTRL_Bu
             -ffer[3] == 0x01)) &&
1765                       (CTRL_Buffer[5] == 0x02))
1766                  {
1767              
1768                    SHARE_Buffer[0]=0x00;
1769                    SHARE_Buffer[1]=0x00;
1770                    ctrlFIFOWrite(2,SHARE_Buffer); 
1771                  }
1772          
1773                  else if(((CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x01)) && (CTRL_Buffer[6] == 0x01))
1774                  {
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 30  

1775              
1776                    SHARE_Buffer[0]=0x00;
1777                    ctrlFIFOWrite(1,SHARE_Buffer); 
1778                  }
1779          
1780                  else if((CTRL_Buffer[3] == 0x04))
1781                  {
1782                    if((CTRL_Buffer[5] == 0x01))
1783                    {
1784          
1785                      SHARE_Buffer[0]=0x08;
1786                      SHARE_Buffer[1]=0x00;
1787                      SHARE_Buffer[2]=0x00;
1788                      SHARE_Buffer[3]=0x00;
1789                      ctrlFIFOWrite(4,SHARE_Buffer);
1790                    }
1791                    else
1792                    {
1793                  
1794                      SHARE_Buffer[0]=0x20;
1795                      SHARE_Buffer[1]=0x00;
1796                      ctrlFIFOWrite(2,SHARE_Buffer);     
1797                    }          
1798                  }
1799          
1800                  else if((CTRL_Buffer[3] == 0x02))
1801                  {
1802                    if((CTRL_Buffer[2] == 0x00))
1803                    {
1804                      if(CTRL_Buffer[6] == 0x02)
1805                      {        
1806                        SHARE_Buffer[0]=0xF6;
1807                        SHARE_Buffer[1]=0xFF;
1808                        ctrlFIFOWrite(2,SHARE_Buffer);
1809                      }
1810                      else if(CTRL_Buffer[5] == 0x01)
1811                      {
1812                        SHARE_Buffer[0]=0x07;
1813                        XBYTE[0xFC34] = 0x23;
1814                      }
1815                    }
1816                    else 
1817                    {
1818          
1819                      SHARE_Buffer[0]=0x00;
1820                      SHARE_Buffer[1]=0xE5;
1821                      ctrlFIFOWrite(2,SHARE_Buffer);
1822                    }
1823              
1824                  }
1825          
1826                  else if((CTRL_Buffer[3] == 0x06))
1827                  {
1828                     
1829                    SHARE_Buffer[0]=0xFB;
1830                    SHARE_Buffer[1]=0xFF;
1831                    ctrlFIFOWrite(2,SHARE_Buffer);
1832                  }
1833          
1834                  else if((CTRL_Buffer[3] == 0x09))
1835                  {
1836                     
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 31  

1837                    SHARE_Buffer[0]=0x64;
1838                    SHARE_Buffer[1]=0x00;
1839                    ctrlFIFOWrite(2,SHARE_Buffer);
1840                  }
1841          
1842                  else if((CTRL_Buffer[3] == 0x0A))
1843                  {
1844                     
1845                    SHARE_Buffer[0]=0xF0;
1846                    SHARE_Buffer[1]=0x0A;
1847                    ctrlFIFOWrite(2,SHARE_Buffer);
1848                  }
1849          
1850                  else if((CTRL_Buffer[3] == 0x0A))
1851                  {
1852                     
1853                    SHARE_Buffer[0]=0xF0;
1854                    SHARE_Buffer[1]=0x0A;
1855                    ctrlFIFOWrite(2,SHARE_Buffer);
1856                  }
1857                  else if( (CTRL_Buffer[3] == 0x01) )
1858                  {
1859                      for(i = 0;i < 26;i++)
1860                      {
1861                          SHARE_Buffer[i]=0x00;
1862                      }
1863                      
1864                      if(test_flag == 1)
1865                      {
1866                        SHARE_Buffer[2]=0x01;
1867                        SHARE_Buffer[3]=0x01;
1868                        SHARE_Buffer[4]=0x15;
1869                        SHARE_Buffer[5]=0x16;
1870                        SHARE_Buffer[6]=0x05;
1871                        SHARE_Buffer[19]=0x60;
1872                        SHARE_Buffer[20]=0x09;
1873                        SHARE_Buffer[22]=0x00;
1874                        SHARE_Buffer[23]=0x0C;            
1875                      }
1876                      else
1877                      {
1878                        SHARE_Buffer[2]=0x01;
1879                        SHARE_Buffer[3]=0x01;
1880                        SHARE_Buffer[4]=0x15;
1881                        SHARE_Buffer[5]=0x16;
1882                        SHARE_Buffer[6]=0x05;
1883                        SHARE_Buffer[19]=0x60;
1884                        SHARE_Buffer[20]=0x09;
1885                        SHARE_Buffer[22]=0x80;
1886                        SHARE_Buffer[23]=0x0A;
1887                      }
1888                        ctrlFIFOWrite(26,SHARE_Buffer); 
1889                  }
1890          
1891              }  
1892          
1893              // GET_MAX
1894              if(CTRL_Buffer[1] == 0x83) 
1895              {
1896                  if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) 
1897                  {
1898                  
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 32  

1899                    SHARE_Buffer[0]=0xFF;
1900                    SHARE_Buffer[1]=0xFF;
1901                    SHARE_Buffer[2]=0xFF;
1902                    SHARE_Buffer[3]=0xFF;
1903                    ctrlFIFOWrite(4,SHARE_Buffer);
1904                  }
1905          
1906                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02) && (CTRL_Buffer[3] == 0x07) ))
1907                  {
1908              
1909                    SHARE_Buffer[0]=0x0A;
1910                    SHARE_Buffer[1]=0x00;
1911                    ctrlFIFOWrite(2,SHARE_Buffer); 
1912              
1913                  }
1914                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && ((CTRL_Buffer[3] == 0x02 ||
1915                        (CTRL_Buffer[3] == 0x08))))
1916                  {
1917              
1918                    SHARE_Buffer[0]=0x0A;
1919                    SHARE_Buffer[1]=0x00;
1920                    ctrlFIFOWrite(2,SHARE_Buffer); 
1921              
1922                  }
1923          
1924                  else if((CTRL_Buffer[3] == 0x04))
1925                  {
1926                    if((CTRL_Buffer[5] == 0x01))
1927                    {
1928                 
1929                      SHARE_Buffer[0]=0x00;
1930                      SHARE_Buffer[1]=0x40;
1931                      SHARE_Buffer[2]=0x00;
1932                      SHARE_Buffer[3]=0x00;
1933                      ctrlFIFOWrite(4,SHARE_Buffer); 
1934                    }
1935                    else if((CTRL_Buffer[5] == 0x02))
1936                    {
1937                   
1938                      SHARE_Buffer[0]=0x30;
1939                      SHARE_Buffer[1]=0x00;
1940                      ctrlFIFOWrite(2,SHARE_Buffer);
1941                 
1942                    }
1943                        
1944                  }
1945          
1946                  else if((CTRL_Buffer[3] == 0x03))
1947                  {
1948              
1949                    SHARE_Buffer[0]=0x14;
1950                    SHARE_Buffer[1]=0x00;
1951                    ctrlFIFOWrite(2,SHARE_Buffer); 
1952                  }
1953          
1954                  else if((CTRL_Buffer[3] == 0x06))
1955                  {
1956              
1957                    SHARE_Buffer[0]=0x05;
1958                    SHARE_Buffer[1]=0x00;
1959                    ctrlFIFOWrite(2,SHARE_Buffer); 
1960                  }
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 33  

1961          
1962                  else if((CTRL_Buffer[3] == 0x09))
1963                  {
1964              
1965                    SHARE_Buffer[0]=0xC8;
1966                    SHARE_Buffer[1]=0x00;
1967                    ctrlFIFOWrite(2,SHARE_Buffer); 
1968                  }
1969          
1970                  else if((CTRL_Buffer[3] == 0x0A))
1971                  {   
1972                    SHARE_Buffer[0]=0x64;
1973                    SHARE_Buffer[1]=0x19;
1974                    ctrlFIFOWrite(2,SHARE_Buffer); 
1975                  }
1976          
1977                  else if((CTRL_Buffer[3] == 0x01))
1978                  {
1979              
1980                    if((CTRL_Buffer[5] == 0x02))
1981                    {
1982                   
1983                      SHARE_Buffer[0]=0x01;
1984                      SHARE_Buffer[1]=0x00;
1985                      ctrlFIFOWrite(2,SHARE_Buffer);  
1986                    }
1987                    else if( (CTRL_Buffer[4] == 0x01) )  
1988                    {
1989                      for(i = 0;i < 26;i++)
1990                      {
1991                          SHARE_Buffer[i]=0x00;
1992                      }
1993                      
1994                      if(test_flag == 1)
1995                      {
1996                        SHARE_Buffer[2]=0x01;
1997                        SHARE_Buffer[3]=0x01;
1998                        SHARE_Buffer[4]=0x15;
1999                        SHARE_Buffer[5]=0x16;
2000                        SHARE_Buffer[6]=0x05;
2001                        SHARE_Buffer[19]=0x60;
2002                        SHARE_Buffer[20]=0x09;
2003                        SHARE_Buffer[22]=0x00;
2004                        SHARE_Buffer[23]=0x0C;            
2005                      }
2006                      else
2007                      {
2008                        SHARE_Buffer[2]=0x01;
2009                        SHARE_Buffer[3]=0x01;
2010                        SHARE_Buffer[4]=0x15;
2011                        SHARE_Buffer[5]=0x16;
2012                        SHARE_Buffer[6]=0x05;
2013                        SHARE_Buffer[19]=0x60;
2014                        SHARE_Buffer[20]=0x09;
2015                        SHARE_Buffer[22]=0x80;
2016                        SHARE_Buffer[23]=0x0A;          
2017                      }
2018          
2019                        ctrlFIFOWrite(26,SHARE_Buffer); 
2020                    }
2021                    else
2022                    {
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 34  

2023                   
2024                        SHARE_Buffer[0]=0xFF;
2025                        ctrlFIFOWrite(1,SHARE_Buffer);
2026                    }
2027                      
2028              
2029                  }
2030          
2031                  else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02))
2032                  {
2033              
2034                     SHARE_Buffer[0]=0x02;
2035                     ctrlFIFOWrite(1,SHARE_Buffer); 
2036                  }
2037          
2038                  else if((CTRL_Buffer[2] == 0x01))
2039                  {
2040              
2041                     SHARE_Buffer[0]=0x00;
2042                     SHARE_Buffer[1]=0x15;
2043                     ctrlFIFOWrite(2,SHARE_Buffer); 
2044                  }
2045                  else if( (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x00) & (CTRL_Buffer[4] == 0x00))
2046                  {
2047                     SHARE_Buffer[0]=0x07;
2048                     XBYTE[0xFC34] = 0x23;
2049                  }
2050                  else
2051                  { 
2052                     XBYTE[0xFC34] = 0x23;  
2053                        
2054                  }
2055          
2056              }  // end GET_MAX
2057          
2058          
2059              // GET_RES
2060              if(CTRL_Buffer[1] == 0x84) 
2061              {
2062                  if (((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) || ((CTRL_Buffer[5] == 0x01) && (CTRL_B
             -uffer[6] == 0x04))) 
2063                  {
2064                  
2065                    SHARE_Buffer[0]=0x01;
2066                    SHARE_Buffer[1]=0x00;
2067                    SHARE_Buffer[2]=0x00;
2068                    SHARE_Buffer[3]=0x00;
2069                    ctrlFIFOWrite(4,SHARE_Buffer);
2070                  }
2071          
2072                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && (CTRL_Buffer[6] == 0x02))
2073                  {
2074              
2075                    SHARE_Buffer[0]=0x01;
2076                    SHARE_Buffer[1]=0x00;
2077                    ctrlFIFOWrite(2,SHARE_Buffer); 
2078              
2079                  }
2080          
2081                  else if((CTRL_Buffer[3] == 0x01) || ((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02)))
2082                  {
2083              
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 35  

2084                    SHARE_Buffer[0]=0x01;
2085                    ctrlFIFOWrite(1,SHARE_Buffer);
2086                  }
2087          
2088                  else if((CTRL_Buffer[2] == 0x01))
2089                  {
2090              
2091                    SHARE_Buffer[0]=0x00;
2092                    SHARE_Buffer[1]=0x01;
2093                    ctrlFIFOWrite(2,SHARE_Buffer);
2094                  }
2095          
2096                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01)) && (CTRL_Buffer[6] == 0x02))
2097                  {
2098              
2099                    SHARE_Buffer[0]=0x01;
2100                    SHARE_Buffer[1]=0x00;
2101                    ctrlFIFOWrite(2,SHARE_Buffer); 
2102                  }
2103                  else if(((CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x01)) && ( (CTRL_Buffer[6] == 0x01) || (CTRL
             -_Buffer[6] == 0x04) ) )
2104                  {
2105              
2106                    SHARE_Buffer[0]=0x09;
2107                    ctrlFIFOWrite(1,SHARE_Buffer); 
2108                  }
2109              } //  end GET_RES
2110          
2111          
2112              // GET_DEF
2113              if(CTRL_Buffer[1] == 0x87) 
2114              {
2115                if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) 
2116                {
2117                  
2118                  SHARE_Buffer[0]=0x00;
2119                  SHARE_Buffer[1]=0x00;
2120                  SHARE_Buffer[2]=0x00;
2121                  SHARE_Buffer[3]=0x00;
2122                  ctrlFIFOWrite(4,SHARE_Buffer);
2123                }
2124          
2125                else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01))
2126                {
2127              
2128                  SHARE_Buffer[0]=0x00;
2129                  SHARE_Buffer[1]=0x02;
2130                  SHARE_Buffer[2]=0x00;
2131                  SHARE_Buffer[3]=0x00;
2132                  ctrlFIFOWrite(4,SHARE_Buffer); 
2133                }
2134          
2135                else if((CTRL_Buffer[3] == 0x02))
2136                {
2137                  if(CTRL_Buffer[6] == 0x02)
2138                  { 
2139                     SHARE_Buffer[0]=0x02;
2140                     SHARE_Buffer[1]=0x00;
2141                     ctrlFIFOWrite(2,SHARE_Buffer); 
2142                  }
2143                  else if(CTRL_Buffer[6] == 0x01)
2144                  {
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 36  

2145                     SHARE_Buffer[0]=0x08;
2146                     ctrlFIFOWrite(1,SHARE_Buffer); 
2147                  }
2148                }
2149          
2150                else if((CTRL_Buffer[3] == 0x03))
2151                {
2152              
2153                  SHARE_Buffer[0]=0x0A;
2154                  SHARE_Buffer[1]=0x00;
2155                  ctrlFIFOWrite(2,SHARE_Buffer); 
2156                }
2157          
2158                else if((CTRL_Buffer[3] == 0x06))
2159                {
2160              
2161                  SHARE_Buffer[0]=0x00;
2162                  SHARE_Buffer[1]=0x00;
2163                  ctrlFIFOWrite(2,SHARE_Buffer); 
2164                }
2165          
2166                else if(((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x02)))
2167                {
2168              
2169                  SHARE_Buffer[0]=0x04;
2170                  SHARE_Buffer[1]=0x00;
2171                  ctrlFIFOWrite(2,SHARE_Buffer); 
2172                }
2173          
2174                else if((CTRL_Buffer[3] == 0x08))
2175                {
2176              
2177                  SHARE_Buffer[0]=0x04;
2178                  SHARE_Buffer[1]=0x00;
2179                  ctrlFIFOWrite(2,SHARE_Buffer); 
2180                } 
2181          
2182                else if((CTRL_Buffer[3] == 0x09))
2183                {
2184              
2185                  SHARE_Buffer[0]=0x82;
2186                  SHARE_Buffer[1]=0x00; 
2187                  ctrlFIFOWrite(2,SHARE_Buffer);
2188                }
2189          
2190                else if((CTRL_Buffer[3] == 0x0A))
2191                {
2192              
2193                  SHARE_Buffer[0]=0x64;
2194                  SHARE_Buffer[1]=0x19;
2195                  ctrlFIFOWrite(2,SHARE_Buffer); 
2196                }
2197          
2198                else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x02))
2199                {
2200              
2201                  SHARE_Buffer[0]=0x01;
2202                  SHARE_Buffer[1]=0x00;
2203                  ctrlFIFOWrite(2,SHARE_Buffer); 
2204                }
2205          
2206                else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02))
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 37  

2207                { 
2208                  SHARE_Buffer[0]=0x22;
2209                  SHARE_Buffer[1]=0x00;
2210                  ctrlFIFOWrite(2,SHARE_Buffer); 
2211                }
2212          
2213                else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02))
2214                {
2215              
2216                  SHARE_Buffer[0]=0x02;
2217                  ctrlFIFOWrite(1,SHARE_Buffer);
2218                }
2219          
2220                else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x04))
2221                {
2222                  SHARE_Buffer[0]=0x00;
2223                  ctrlFIFOWrite(1,SHARE_Buffer); 
2224                }
2225              } // end GET_DEF
2226          
2227              // GET_CUR
2228              if((CTRL_Buffer[1] == 0x81)) 
2229              {
2230                if((CTRL_Buffer[3] == 0x02)) 
2231                {
2232                  if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x01))
2233                  {  // Request error code control
2234                
2235                    ctrlFIFOWrite(1,SHARE_Buffer);
2236                
2237                  }
2238          
2239                  else if((CTRL_Buffer[4] == 0x02) && (CTRL_Buffer[5] == 0x02))
2240                  {
2241                 
2242                    SHARE_Buffer[0]=0x00;
2243                    SHARE_Buffer[1]=0x0B;
2244                    ctrlFIFOWrite(2,SHARE_Buffer);
2245                  }
2246          
2247                  else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02))
2248                  {
2249                  
2250                    SHARE_Buffer[0]=0x06;
2251                    XBYTE[0xFC34] = 0x23;
2252                  }
2253                  
2254                  else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01))
2255                  {
2256                    SHARE_Buffer[0]=0x06;
2257                    XBYTE[0xFC34] = 0x23;         
2258                  }
2259                }
2260          
2261                else if(CTRL_Buffer[3] == 0x01)
2262                {
2263          
2264                  if((CTRL_Buffer[4] == 0x02))
2265                  {
2266                 
2267                    SHARE_Buffer[0]=0x00;
2268                    ctrlFIFOWrite(1,SHARE_Buffer);
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 38  

2269                  }
2270              
2271                  else if( (CTRL_Buffer[4] == 0x00) && ( (CTRL_Buffer[5] == 0x01) || (CTRL_Buffer[5] == 0x02) ) ) 
2272                  {
2273                    SHARE_Buffer[0]=0x06;
2274                    XBYTE[0xFC34] = 0x23;
2275                  }
2276          
2277                  else if((CTRL_Buffer[4] == 0x01)) 
2278                  {
2279                     
2280                    if (test_flag == 0)
2281                    {
2282                      for(i = 0;i < 26;i++)
2283                      {
2284                          SHARE_Buffer[i]=0x00;
2285                      }
2286                      SHARE_Buffer[2]=0x01;
2287                      SHARE_Buffer[3]=0x01;
2288                      SHARE_Buffer[4]=0x15;
2289                      SHARE_Buffer[5]=0x16;
2290                      SHARE_Buffer[6]=0x05;
2291                      SHARE_Buffer[19]=0x60;
2292                      SHARE_Buffer[20]=0x09;
2293                      SHARE_Buffer[22]=0x80;
2294                      SHARE_Buffer[23]=0x0A;
2295                      ctrlFIFOWrite(26,SHARE_Buffer);
2296                      test_flag = 1;
2297                    }       
2298                    else
2299                    {
2300                      for(i = 0;i < 26;i++)
2301                      {
2302                          SHARE_Buffer[i]=0x00;
2303                      }
2304                      SHARE_Buffer[2]=0x01;
2305                      SHARE_Buffer[3]=0x01;
2306                      SHARE_Buffer[4]=0x15;
2307                      SHARE_Buffer[5]=0x16;
2308                      SHARE_Buffer[6]=0x05;
2309                      SHARE_Buffer[19]=0x60;
2310                      SHARE_Buffer[20]=0x09;
2311                      SHARE_Buffer[22]=0x00;
2312                      SHARE_Buffer[23]=0x0C;
2313                      ctrlFIFOWrite(26,SHARE_Buffer);
2314                    }
2315                   
2316                  }
2317              
2318                }
2319          
2320                else if(CTRL_Buffer[3] == 0x03)
2321                {
2322                    if(CTRL_Buffer[4] == 0x00)
2323                    {
2324                      SHARE_Buffer[0]=0x06;
2325                      XBYTE[0xFC34] = 0x23;
2326                    }
2327          
2328                    else if(CTRL_Buffer[4] == 0x01)
2329                    {
2330                      if(test_flag == 1)
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 39  

2331                      {
2332                        SHARE_Buffer[0]=0x01;
2333                        SHARE_Buffer[1]=0x01;
2334                        SHARE_Buffer[2]=0x00;
2335                        SHARE_Buffer[3]=0x00;
2336                        SHARE_Buffer[4]=0x06;
2337                        SHARE_Buffer[5]=0x09;
2338                        SHARE_Buffer[6]=0x00;
2339                        SHARE_Buffer[7]=0x80;
2340                        SHARE_Buffer[8]=0x0A;
2341                        SHARE_Buffer[9]=0x00;
2342                        SHARE_Buffer[10]=0x00;
2343                        ctrlFIFOWrite(11,SHARE_Buffer);
2344                        test_flag = 3;
2345                      }
2346          
2347                      else
2348                      {
2349                        SHARE_Buffer[0]=0x01;
2350                        SHARE_Buffer[1]=0x01;
2351                        SHARE_Buffer[2]=0x00;
2352                        SHARE_Buffer[3]=0x00;
2353                        SHARE_Buffer[4]=0x06;
2354                        SHARE_Buffer[5]=0x09;
2355                        SHARE_Buffer[6]=0x00;
2356                        SHARE_Buffer[7]=0x00;
2357                        SHARE_Buffer[8]=0x0C;
2358                        SHARE_Buffer[9]=0x00;
2359                        SHARE_Buffer[10]=0x00;
2360                        ctrlFIFOWrite(11,SHARE_Buffer);
2361                      }
2362                    }
2363                    
2364              
2365                }
2366          
2367                else if( (CTRL_Buffer[3] == 0x04) || (CTRL_Buffer[3] == 0x0C) || (CTRL_Buffer[3] == 0x0F) ||
2368                     (CTRL_Buffer[3] == 0x10) || (CTRL_Buffer[3] == 0x0D) || (CTRL_Buffer[3] == 0x0E) ||
2369                               (CTRL_Buffer[3] == 0x11) || (CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x12) ||
2370                     (CTRL_Buffer[3] == 0x0B) || (CTRL_Buffer[3] == 0x0A) || (CTRL_Buffer[3] == 0x09) ||
2371                     (CTRL_Buffer[3] == 0x08) || (CTRL_Buffer[3] == 0x07) || (CTRL_Buffer[3] == 0x06) )
2372                {
2373                    SHARE_Buffer[0]=0x06;
2374                    XBYTE[0xFC34] = 0x23;
2375                    
2376                }
2377          
2378              }  // end GET_CUR
2379          
2380              
2381              
2382              // GET_LEN
2383              if(CTRL_Buffer[1] == 0x85) 
2384              {
2385                if ( (CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x07) || (CTRL_Buffer[3] == 0x10) ||
2386                      (CTRL_Buffer[3] == 0x18)) 
2387                {
2388                  
2389                  SHARE_Buffer[0]=0x04;
2390                  SHARE_Buffer[1]=0x00;
2391                  ctrlFIFOWrite(2,SHARE_Buffer);
2392                }
C51 COMPILER V9.00   USBLIBPRO                                                             01/20/2014 14:45:32 PAGE 40  

2393                else if( (CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01) && (CTRL_Buffer[6] == 0x04))
2394                {
2395                  SHARE_Buffer[0]=0x07;
2396                  XBYTE[0xFC34] = 0x23;       
2397                }
2398          
2399                else if(CTRL_Buffer[3] == 0x01)
2400                {
2401              
2402                  SHARE_Buffer[0]=0x01;
2403                  SHARE_Buffer[1]=0x00;
2404                  ctrlFIFOWrite(2,SHARE_Buffer);
2405              
2406                }
2407                else if( (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x01))
2408                {
2409                  SHARE_Buffer[0]=0x07;
2410                  XBYTE[0xFC34] = 0x23;
2411                }
2412                else
2413                {
2414                  XBYTE[0xFC34] = 0x23; 
2415                }
2416          
2417              }  // end GET_LEN
2418            }
2419          }   // end usb_video_class_function()
2420          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3700    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
