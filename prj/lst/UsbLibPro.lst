C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE USBLIBPRO
OBJECT MODULE PLACED IN .\bin\UsbLibPro.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\UsbLibPro.c BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\UsbLibPro.lst) TABS(2
                    -) OBJECT(.\bin\UsbLibPro.obj)

line level    source

   1          #include "platform.h"
   2          
   3          
   4          void usb_video_class_function();
   5          unsigned char usbGetStatus();
   6          unsigned char usbClearFeature();
   7          unsigned char usbSetFeature();
   8          unsigned char usbSetAddress();
   9          unsigned char usbGetDescriptor();
  10          unsigned char usbGetConfig();
  11          unsigned char usbSetConfig();
  12          unsigned char usbGetInterface();
  13          unsigned char usbSetInterface();
  14          
  15          
  16          void controlCMD()
  17          {
  18   1        unsigned char x;
  19   1        x = ctrlFIFORead(8, CTRL_Buffer);
  20   1      
  21   1        //Decode the 8-byte SETUP pkt data
  22   1        _bmRequestType = CTRL_Buffer[0];
  23   1        _bRequest = CTRL_Buffer[1];
  24   1        _wValue = TOWORD(CTRL_Buffer[3], CTRL_Buffer[2]);
  25   1        _wIndex = TOWORD(CTRL_Buffer[5], CTRL_Buffer[4]);
  26   1        _wLength = TOWORD(CTRL_Buffer[7], CTRL_Buffer[6]);
  27   1        
  28   1        if( x == TRUE ){
  29   2          if((_bmRequestType==0x21) || (_bmRequestType==0xA1)){
  30   3            usb_video_class_function();
  31   3          } else {
  32   3            switch(_bRequest){
  33   4              case BR_GET_STATUS:
  34   4                x = usbGetStatus();
  35   4                break;
  36   4              case BR_CLEAR_FEATURE:
  37   4                x = usbClearFeature();
  38   4                //XBYTE[0xFC34] = 0x21;
  39   4                break;
  40   4              case BR_SET_FEATURE:
  41   4                x = usbSetFeature();
  42   4                break;
  43   4              case BR_SET_ADDRESS:
  44   4                x = usbSetAddress();
  45   4                break;
  46   4              case BR_GET_DESCRIPTOR:
  47   4                x = usbGetDescriptor();
  48   4                break;
  49   4              case BR_GET_CONFIGURATION:
  50   4                x = usbGetConfig();
  51   4                break;
  52   4              case BR_SET_CONFIGURATION:
  53   4                x = usbSetConfig();
  54   4                break;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 2   

  55   4              case BR_GET_INTERFACE:
  56   4                x = usbGetInterface();
  57   4                break;
  58   4              case BR_SET_INTERFACE:
  59   4                x = usbSetInterface();
  60   4                break;
  61   4              default:
  62   4                x = USB_STALL;
  63   4                break;
  64   4            }
  65   3          }
  66   2        }
  67   1      }
  68          
  69          
  70          
  71          unsigned char usbGetStatus()
  72          {
  73   1        unsigned char x=0x00;
  74   1      
  75   1        // Check the Request integrity:
  76   1        // wValue must be 0
  77   1        // wLength must be 2
  78   1        if ((_wValue != 0)||(_wLength != 2)){
  79   2          XBYTE[EP0_CTRL] = 0x23; // endpoin stall
  80   2          return USB_STALL;
  81   2        }
  82   1      
  83   1        switch( _bmRequestType){
  84   2          case 0x80:  //Device status
  85   2            if (_wIndex == 0){
  86   3              if(!busPowered){
  87   4                x |= 0x01;
  88   4              }
  89   3              if(RemoteWakeup){
  90   4                x |= 0x02;
  91   4              }
  92   3            }
  93   2            else{
  94   3              XBYTE[EP0_CTRL] = 0x23; // endpoin stall
  95   3              return USB_STALL;
  96   3            }
  97   2                break;
  98   2          case 0x81:  //Interface status. Get Status is used to return the status of the interface. Such a request 
             -to the interface should return two bytes of 0x00, 0x00. (Both bytes are reserved for future use)
  99   2            //if(LOW_BYTE(_wIndex) <= IF_MAX_DESCR){ //IF_MAX_DESCR (HidDisabled ? 0 : 2)
 100   2              //richc, should return 2 byte of 0x00
 101   2              x = 0x00;
 102   2            //}
 103   2            //else{
 104   2              //XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 105   2              //return USB_STALL;
 106   2            //}
 107   2                break;
 108   2            case 0x82:  //Endpoint status. Get Status returns two bytes indicating the status (Halted/Stalled) of 
             -a endpoint.
 109   2              _wIndex &= 0x0F;
 110   2              if(_wIndex > 4){//EP_MAX_DESCR=4
 111   3                XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 112   3                return USB_STALL;
 113   3            }
 114   2      
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 3   

 115   2            switch(_wIndex){// CTRL_Buffer[4], LSB of wIndex specify EP
 116   3              case 0x00:  // Control EP
 117   3                x = XBYTE[EP0_CTRL];
 118   3                break;
 119   3              case 0x01:  // EP1 (OUT endpoint)
 120   3                x = XBYTE[EP1_CTRL];
 121   3                break;
 122   3              case 0x82:  // EP2 (IN Endpoint)
 123   3                x = XBYTE[EP2_CTRL];
 124   3                break;
 125   3              default:
 126   3                XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 127   3                return USB_STALL;
 128   3            }
 129   2      
 130   2            if( x & 0x02 ) {  // Check Endpoint Stall flag (bit 1)
 131   3              x = 0x01;     // Set HALT Flag in the returned value if EP is Stalled
 132   3            } else {
 133   3              x = 0x00;     // Do Not Set HALT Flag in the returned value if EP is Not Stalled
 134   3            }
 135   2            break;
 136   2          default:
 137   2            return USB_STALL;
 138   2        }
 139   1      
 140   1        XBYTE[CONTROL_FIFO] = x;    // Put the result to EP0 FIFO (LSB of the returned STATUS)
 141   1        XBYTE[CONTROL_FIFO+1] = 0;    // Put 0 byte to EP0 FIFO (MSB of the returned STATUS)
 142   1        XBYTE[EP0_CTRL] |= 0x01;    // Set Endpoint Done flag to transfer the data
 143   1      
 144   1        return USB_DONE;
 145   1      }
 146          
 147          unsigned char usbClearFeature()
 148          {
 149   1        if(_wLength!=0){
 150   2        //if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) ) {
 151   2          XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 152   2          return USB_STALL;
 153   2        }
 154   1      
 155   1        switch(_bmRequestType){
 156   2          case BMR_REC_DEVICE:
 157   2            if(_wIndex !=0){
 158   3              XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 159   3              return USB_STALL;
 160   3            }
 161   2      
 162   2            if(LOW_BYTE(_wValue)== FTR_DEVICE_REMOTE_WAKEUP){
 163   3              //if(desc.Attri)
 164   3              RemoteWakeup = 0;
 165   3              //else STALL
 166   3            }else{
 167   3              XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 168   3              return USB_STALL;
 169   3            }
 170   2              break;
 171   2      
 172   2          case BMR_REC_INTERFACE:
 173   2          return USB_STALL;
 174   2          break;
 175   2          
 176   2        case BMR_REC_ENDPOINT:
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 4   

 177   2          if(LOW_BYTE(_wValue)==FTR_ENDPOINT_HALT){
 178   3            
 179   3            _wIndex &= 0x0F;
 180   3            //if( CTRL_Buffer[5] != 0 ) {
 181   3            if(LOW_BYTE(_wIndex) >= 4){ //EP_MAX_DESCR
 182   4              XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 183   4              return USB_STALL;
 184   4            }
 185   3      
 186   3            switch(LOW_BYTE(_wIndex)){
 187   4              case 0x00:
 188   4                XBYTE[EP0_CTRL] = 0x18;
 189   4                break;
 190   4              case 0x01:
 191   4                XBYTE[EP1_CTRL] = 0x28;
 192   4                XBYTE[ENP_TOG_CLR] = 0x02;
 193   4                //  XBYTE[USB3_FIFO_FLUSH_CTRL] = 0x03;
 194   4                break;
 195   4              case 0x82:
 196   4                XBYTE[EP2_CTRL] = 0x10;
 197   4                XBYTE[ENP_TOG_CLR] = 0x04;
 198   4                break;
 199   4              default:
 200   4                XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 201   4                return USB_STALL;
 202   4            }
 203   3          }
 204   2          else{
 205   3            XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 206   3            return USB_STALL;
 207   3          }
 208   2          break;
 209   2      
 210   2        default:
 211   2          XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 212   2          return USB_STALL;
 213   2        }
 214   1      
 215   1        XBYTE[EP0_CTRL] = 0x21;
 216   1        return USB_DONE;
 217   1      }
 218          
 219          unsigned char usbSetFeature()
 220          {
 221   1        if(_wLength != 0){
 222   2          XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 223   2          return USB_STALL;
 224   2        }
 225   1      
 226   1        switch(_bmRequestType){
 227   2      
 228   2          case BMR_REC_DEVICE:
 229   2                if(LOW_BYTE(_wValue) == FTR_DEVICE_REMOTE_WAKEUP ) {
 230   3              RemoteWakeup = 1;
 231   3            //Ignore FTR_DEVICE_TEST_MODE
 232   3            /*
 233   3                  } else if( CTRL_Buffer[2] == FTR_DEVICE_TEST_MODE ) {
 234   3                        if( (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] > 4) || (CTRL_Buffer[5] == 0) ) {
 235   3                            return USB_STALL;
 236   3                        }
 237   3                    
 238   3                        TEST_MODE = CTRL_Buffer[5] | 0x08;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 5   

 239   3                      }
 240   3            */
 241   3            }else{
 242   3              XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 243   3              return USB_STALL;
 244   3            }
 245   2            break;
 246   2      
 247   2          case BMR_REC_INTERFACE:
 248   2            XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 249   2            return USB_STALL;
 250   2            break;
 251   2            
 252   2          case BMR_REC_ENDPOINT:
 253   2            if(LOW_BYTE(_wValue) == FTR_ENDPOINT_HALT ) {
 254   3              
 255   3              //if( CTRL_Buffer[5] != 0 ) {
 256   3              if(LOW_BYTE(_wIndex) >= 4){ //EP_MAX_DESCR
 257   4                XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 258   4                return USB_STALL;
 259   4              }
 260   3      
 261   3              switch(LOW_BYTE(_wIndex)) {
 262   4                case 0x00:
 263   4                  XBYTE[EP0_CTRL] = 0x1A;
 264   4                  break;
 265   4                case 0x01:
 266   4                  XBYTE[EP1_CTRL] = 0x2A;
 267   4                  break;
 268   4                case 0x82:
 269   4                  XBYTE[EP2_CTRL] = 0x12;
 270   4                  break;
 271   4                default:
 272   4                  XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 273   4                  return USB_STALL;
 274   4              }
 275   3            } else {
 276   3              XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 277   3              return USB_STALL;
 278   3            }
 279   2            break;
 280   2            
 281   2          default:
 282   2            XBYTE[EP0_CTRL] = 0x23; // endpoin stall
 283   2            return USB_STALL;
 284   2          }
 285   1      
 286   1        return USB_DONE;
 287   1      }
 288          
 289          unsigned char usbSetAddress()
 290          {
 291   1      /*
 292   1        if( (CTRL_Buffer[2] & 0x80) || (CTRL_Buffer[3] != 0) ||
 293   1                  (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) ||
 294   1                  (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) ) {
 295   1              return USB_STALL;
 296   1        }
 297   1      */
 298   1        bDeviceAddress = LOW_BYTE(_wValue);
 299   1        DEVICE0_ADDRESS = bDeviceAddress;
 300   1      
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 6   

 301   1        XBYTE[EP0_CTRL] = 0x21;
 302   1        return USB_DONE;
 303   1      }
 304          
 305          unsigned char usbGetDescriptor()
 306          {
 307   1        unsigned char code *descp;
 308   1        unsigned short rlen;
 309   1        unsigned short cmd_len = 0;
 310   1        unsigned int  offset = 0;
 311   1        
 312   1        cmd_len = (CTRL_Buffer[7]*256 ) +  CTRL_Buffer[6];
 313   1      
 314   1        switch( CTRL_Buffer[3] ) {
 315   2      
 316   2          case DS_DEVICE:                     // Device Descriptor
 317   2              rlen = Ide_Dvc_Dlen;
 318   2              descp = device_desc;
 319   2              if( (CTRL_Buffer[6] < rlen) ) {
 320   3                  rlen = CTRL_Buffer[6];
 321   3              }
 322   2              ctrlFIFOWrite(rlen,descp);
 323   2          case DS_CONFIGURATION:              // Configuration Descriptor
 324   2              descp = UVC_Std_D;
 325   2              rlen = UVC_Std_D_len;
 326   2              if( (cmd_len < rlen) ) {
 327   3                  rlen = cmd_len;
 328   3              }
 329   2              ctrlFIFOWrite(rlen,descp);
 330   2              break;
 331   2          case DS_STRING:                     // String Descriptor
 332   2              switch( CTRL_Buffer[2] ) {
 333   3                case 0x00:    // LangID string
 334   3                    rlen = Ide_Str0_Dlen;
 335   3                    descp = string_desc0;
 336   3                    if( (CTRL_Buffer[6] < rlen) ) {
 337   4                        rlen = CTRL_Buffer[6];
 338   4                    }
 339   3                    ctrlFIFOWrite(rlen,descp);
 340   3                    break;
 341   3                case 0x01:
 342   3                    rlen = Ide_Str1_Dlen;
 343   3                    descp = string_desc1;
 344   3                    if( (CTRL_Buffer[6] < rlen) ) {
 345   4                        rlen = CTRL_Buffer[6];
 346   4                    }
 347   3                    ctrlFIFOWrite(rlen,descp);
 348   3                    break;
 349   3                case 0x02:
 350   3                    rlen = Ide_Str2_Dlen;
 351   3                    descp = string_desc2;
 352   3                    if( (CTRL_Buffer[6] < rlen) ) {
 353   4                        rlen = CTRL_Buffer[6];
 354   4                    }
 355   3                    ctrlFIFOWrite(rlen,descp);
 356   3                    // XBYTE[ENP_IRE_STORE] |= 0x01;
 357   3                    break;
 358   3                case 0x03:
 359   3                    rlen = Ide_Str3_Dlen;
 360   3                    descp = string_desc3;
 361   3                    if( (CTRL_Buffer[6] < rlen) ) {
 362   4                        rlen = CTRL_Buffer[6];
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 7   

 363   4                    }
 364   3                    ctrlFIFOWrite(rlen,descp);
 365   3                    //XBYTE[ENP_IRE_STORE] |= 0x01;
 366   3                    break;
 367   3                default:
 368   3                    return USB_STALL;
 369   3              }
 370   2              break;
 371   2          case DS_DEVICE_QUALIFIER:           // Device_Qualifier Descriptor
 372   2              rlen = Ide_Dvc_QF_Dlen;
 373   2              descp = Ide_Dvc_QF_D;
 374   2              if( (CTRL_Buffer[6] < rlen) ) {
 375   3                  rlen = CTRL_Buffer[6];
 376   3              }
 377   2              ctrlFIFOWrite(rlen,descp);
 378   2              break;
 379   2          case DS_INTERFACE_POWER:            // Interface Power Configuration
 380   2              return USB_STALL;
 381   2          default:
 382   2              return USB_STALL;
 383   2          }
 384   1          
 385   1          return USB_DONE;
 386   1      }
 387          
 388          unsigned char usbGetConfig()
 389          {
 390   1      /*
 391   1          if( (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) ||
 392   1                  (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) ||
 393   1                  (CTRL_Buffer[6] != 1) || (CTRL_Buffer[7] != 0) ) {
 394   1              return USB_STALL;
 395   1          }
 396   1          
 397   1          if( Configed ) {
 398   1              XBYTE[CONTROL_FIFO] = 0x01;
 399   1          } else {
 400   1              XBYTE[CONTROL_FIFO] = 0x00;
 401   1          }
 402   1      */
 403   1        XBYTE[CONTROL_FIFO] = bConfiguration;
 404   1      
 405   1          XBYTE[EP0_CTRL] |= 0x01;
 406   1          return USB_DONE;
 407   1      }
 408          
 409          unsigned char usbSetConfig()
 410          {
 411   1      /*
 412   1        if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) || (CTRL_Buffer[6] != 0) || (
             -CTRL_Buffer[7] != 0) ){
 413   1          XBYTE[EP0_CTRL] = 0x23;
 414   1          return( FALSE );
 415   1        }
 416   1      
 417   1      */
 418   1        switch(LOW_BYTE(_wValue)){
 419   2          case 0:
 420   2            XBYTE[0xFC04] = 0x01; //ENP_EN_L, Disable all other endpoint except enpt 0
 421   2            break;
 422   2          case 1:
 423   2            XBYTE[0xFC04] = 0x7F; //(HidDisabled ? 0x1F : 0x7F), Enable Interrupt In + Bulk In endpoints
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 8   

 424   2            XBYTE[0xFC08] = 0x01; //ENP_InterruptMask_L, Enable EP0 interrupt .... (but why not 0x05, Interrupt In 
             -+ Bulk In interrupt ???)
 425   2      
 426   2            XBYTE[EP1_CTRL] = 0x28;
 427   2            XBYTE[EP2_CTRL] = 0x10;
 428   2            break;
 429   2          default:
 430   2            XBYTE[EP0_CTRL] = 0x23;
 431   2            return USB_STALL;
 432   2        }
 433   1      
 434   1        bConfiguration = LOW_BYTE(_wValue);
 435   1        
 436   1        XBYTE[EP0_CTRL] = 0x21;
 437   1        return USB_DONE;
 438   1      }
 439          
 440          unsigned char usbGetInterface()
 441          {
 442   1          if( (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 1) || (CTRL_Buffer[7] != 0) )
             - {
 443   2              return USB_STALL;
 444   2          }
 445   1      
 446   1          if( Configed ) {
 447   2              XBYTE[CONTROL_FIFO] = 0x00;
 448   2              XBYTE[EP0_CTRL] |= 0x01;
 449   2      
 450   2              return USB_DONE;
 451   2          } else {
 452   2              return USB_STALL;
 453   2          }
 454   1      }
 455          
 456          unsigned char usbSetInterface()
 457          {
 458   1      /*  
 459   1        if((CTRL_Buffer[0] == 0x01) &&
 460   1          (CTRL_Buffer[1] == 0x0B) &&
 461   1          (CTRL_Buffer[2] == 0x07) &&  
 462   1          (CTRL_Buffer[3] == 0x00) &&
 463   1          (CTRL_Buffer[4] == 0x01) && 
 464   1          (CTRL_Buffer[5] == 0x00) &&
 465   1          (CTRL_Buffer[6] == 0x00) &&
 466   1          (CTRL_Buffer[7] == 0x00) 
 467   1        ){
 468   1            GLOBAL_test=1;  
 469   1            //printStr("START_OUT\n");
 470   1        }
 471   1      */
 472   1        XBYTE[EP0_CTRL] |= 0x21;
 473   1        
 474   1        return USB_DONE;
 475   1      }
 476          
 477          void usb_video_class_function()
 478          { 
 479   1        // wLength represents the size of the parameters which will be passed in the data stage
 480   1        // of the control transfer
 481   1        // Potential BUG: just LSB of the wLength is used here. If the parameters length will be
 482   1        // bigger than 255 bytes we will not able to process the request correctly
 483   1        unsigned char UAC_len, i; //wLength
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 9   

 484   1        UAC_len = CTRL_Buffer[6];
 485   1        
 486   1        // Host to Device
 487   1        if((CTRL_Buffer[0] == 0x21)) {  // If SET Request addressed to Entity ID or Interface received.
 488   2          
 489   2          // Read the Request Parameters from the EP0 FIFO
 490   2          // Potential BUG: What if the parameters data are not ready yet? I think some wait timout need to be imp
             -lemented here
 491   2          if (XBYTE[EP0_CTRL+2]==UAC_len) { // If the amount of data in FIFO == wLength
 492   3            // Read out the Request Parameters to the SHARE_Buffer
 493   3            for (i=0; i<UAC_len; i++) {
 494   4              SHARE_Buffer[i] = XBYTE[CONTROL_FIFO+i];
 495   4            }
 496   3          }
 497   2          
 498   2          // If we have
 499   2          // bRequest (Control Attribute ID)  = SET_CUR (Current Setting Attribute = 0x01 ) // CTRL_Buffer[1]
 500   2          // wValue (Control Selector )       = 0x0200 (Control Selector = 0x02 ) // LSB CTRL_Buffer[2], MSB CTRL_Buf
             -fer[3] // WHAT IS CONTROL 0x02 ????
 501   2          // wIndex (Entity ID, Interface )   = 0x0001 (Interface = 0x01, Entity ID = 0x00 for interface ) // LSB C
             -TRL_Buffer[4] - Interface, MSB CTRL_Buffer[5] - Entity ID
 502   2          // wLength ( lengths of the parameter block ) = 0x00A1 // LSB CTRL_Buffer[6], MSB CTRL_Buffer[7]
 503   2          if ((CTRL_Buffer[1] == 0x01) &&
 504   2              (CTRL_Buffer[2] == 0x00) && 
 505   2              (CTRL_Buffer[3] == 0x02) && 
 506   2              (CTRL_Buffer[4] == 0x01) &&
 507   2              (CTRL_Buffer[5] == 0x00) &&
 508   2              (CTRL_Buffer[6] == 0x1A) &&
 509   2              (CTRL_Buffer[7] == 0x00)){
 510   3                //GLOBAL_test = 1;
 511   3          }
 512   2          
 513   2          //???????????????????
 514   2          for (i=0; i<0xFE; i++) 
 515   2          {                 
 516   3          }//Delay for confirming the last data is already written to the register
 517   2              
 518   2          XBYTE[EP0_CTRL] |= 0x04;  //flush control pipe
 519   2          XBYTE[EP0_CTRL] = 0x21;   // Configure Endpoint 0: (bit5) - unmask "Packet of Data being received" interr
             -upt, (bit0) - set Endpoint Done flag
 520   2        }
 521   1        // Device to Host
 522   1        else if((CTRL_Buffer[0] == 0xA1)) { // If GET Request addressed to Entity ID or Interface received
 523   2          
 524   2          if(UAC_len ==0) {
 525   3            // if the parameters data length is 0 (so no data stage expected in the request transfer )
 526   3            // Finalyze request transfer
 527   3            XBYTE[EP0_CTRL] = 0x21;
 528   3            // XBYTE[EP0_CTRL] = 0x21; // Do twice???
 529   3          }
 530   2          
 531   2          
 532   2          // GET_INFO (0x86) Request Processing
 533   2          // The GET_INFO request queries the capabilities and status of the specified control. 
 534   2          // When issuing this request, the wLength field shall always be set to a value of 1 byte. 
 535   2          // The result returned is a bit mask reporting the capabilities of the control. The bits are defined as:
 536   2          // ****************************************************************************************
 537   2          //  Bit field * Description                       * Bit State
 538   2          // ****************************************************************************************
 539   2          //        *                             *
 540   2          //  D0      * 1=Supports GET value requests             * Capability
 541   2          // **************************************************************************************** 
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 10  

 542   2          //  D1      * 1=Supports SET value requests             * Capability
 543   2          // **************************************************************************************** 
 544   2          //  D2      * 1=Disabled due to automatic mode            * State
 545   2          //        * (under device control)                  *
 546   2          // **************************************************************************************** 
 547   2          //  D3      * 1= Autoupdate Control                   * Capability
 548   2          //        * (see section 2.4.2.2 "Status Interrupt Endpoint")   *
 549   2          // ****************************************************************************************
 550   2          //  D4      * 1= Asynchronous Control                 * Capability
 551   2          //        * (see sections 2.4.2.2 "Status Interrupt Endpoint"   *
 552   2          //        * and 2.4.4, ?ontrol Transfer and Request Processing? *
 553   2          // **************************************************************************************** 
 554   2          //  D7..D5    * Reserved (Set to 0)                   * --
 555   2          // ****************************************************************************************
 556   2          if(CTRL_Buffer[1] == USB_UVC_GET_INFO) {
 557   3            
 558   3            if((CTRL_Buffer[3] == 0x03) || (CTRL_Buffer[3] == 0x06) || (CTRL_Buffer[3] == 0x08)||
 559   3                ((CTRL_Buffer[3] == 0x09) && (CTRL_Buffer[5] == 0x02))|| (CTRL_Buffer[3] == 0x01) || (CTRL_Buffer[
             -3] == 0x05) ||
 560   3                (CTRL_Buffer[3] == 0x10) || (CTRL_Buffer[3] == 0x18) || ((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5
             -] == 0x02))||
 561   3                ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02)) || ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer
             -[5] == 0x04))) {
 562   4              SHARE_Buffer[0]=0x03;
 563   4              ctrlFIFOWrite(1, SHARE_Buffer);
 564   4              XBYTE[EP0_CTRL] = 0x21;
 565   4            }
 566   3            /*else if( (CTRL_Buffer[3] == 0x02) ){
 567   3              SHARE_Buffer[0]=0x03;
 568   3              ctrlFIFOWrite(1,SHARE_Buffer);        
 569   3            }*/
 570   3            else if(((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01)) || (CTRL_Buffer[3] == 0x0A)){
 571   4              SHARE_Buffer[0]=0x0F;
 572   4              ctrlFIFOWrite(1, SHARE_Buffer); 
 573   4              XBYTE[EP0_CTRL] = 0x21;
 574   4            }
 575   3            else if((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x04)) {
 576   4              SHARE_Buffer[0]=0x01;
 577   4              ctrlFIFOWrite(1, SHARE_Buffer); 
 578   4              XBYTE[EP0_CTRL] = 0x21;
 579   4            }
 580   3            else {
 581   4              XBYTE[EP0_CTRL] = 0x23; 
 582   4            }
 583   3          } // GET INFO
 584   2          
 585   2          // GET_MIN (0x82)
 586   2          if(CTRL_Buffer[1] == USB_UVC_GET_MIN) {
 587   3            if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) {
 588   4              SHARE_Buffer[0]=0x00;
 589   4              SHARE_Buffer[1]=0x00;
 590   4              SHARE_Buffer[2]=0x00;
 591   4              SHARE_Buffer[3]=0x00;
 592   4              ctrlFIFOWrite(4, SHARE_Buffer);
 593   4              XBYTE[EP0_CTRL] = 0x21;
 594   4            }
 595   3            else if(((CTRL_Buffer[3] == 0x03) || 
 596   3              (CTRL_Buffer[3] == 0x07) || 
 597   3              (CTRL_Buffer[3] == 0x08) || 
 598   3              (CTRL_Buffer[3] == 0x01)) &&
 599   3              (CTRL_Buffer[5] == 0x02)){
 600   4              SHARE_Buffer[0]=0x00;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 11  

 601   4              SHARE_Buffer[1]=0x00;
 602   4              ctrlFIFOWrite(2, SHARE_Buffer); 
 603   4              XBYTE[EP0_CTRL] = 0x21;
 604   4            }
 605   3            else if(((CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x01)) && (CTRL_Buffer[6] == 0x01)) {
 606   4              SHARE_Buffer[0]=0x00;
 607   4              ctrlFIFOWrite(1,SHARE_Buffer); 
 608   4              XBYTE[EP0_CTRL] = 0x21;
 609   4            }
 610   3            else if((CTRL_Buffer[3] == 0x04)){
 611   4              if((CTRL_Buffer[5] == 0x01)){
 612   5                SHARE_Buffer[0]=0x08;
 613   5                SHARE_Buffer[1]=0x00;
 614   5                SHARE_Buffer[2]=0x00;
 615   5                SHARE_Buffer[3]=0x00;
 616   5                ctrlFIFOWrite(4,SHARE_Buffer);
 617   5                XBYTE[EP0_CTRL] = 0x21;
 618   5              }
 619   4              else{
 620   5                SHARE_Buffer[0]=0x20;
 621   5                SHARE_Buffer[1]=0x00;
 622   5                ctrlFIFOWrite(2,SHARE_Buffer);     
 623   5                XBYTE[EP0_CTRL] = 0x21;   
 624   5              }
 625   4            }
 626   3            else if((CTRL_Buffer[3] == 0x02)){
 627   4              if((CTRL_Buffer[2] == 0x00)) {
 628   5                SHARE_Buffer[0]=0xF6;
 629   5                SHARE_Buffer[1]=0xFF;
 630   5                ctrlFIFOWrite(2,SHARE_Buffer);
 631   5                XBYTE[EP0_CTRL] = 0x21;
 632   5              }
 633   4              else{
 634   5                SHARE_Buffer[0]=0x00;
 635   5                SHARE_Buffer[1]=0xE5;
 636   5                ctrlFIFOWrite(2,SHARE_Buffer);
 637   5                XBYTE[EP0_CTRL] = 0x21;
 638   5              }
 639   4            }
 640   3            else if((CTRL_Buffer[3] == 0x06)){
 641   4              SHARE_Buffer[0]=0xFB;
 642   4              SHARE_Buffer[1]=0xFF;
 643   4              ctrlFIFOWrite(2,SHARE_Buffer);
 644   4              XBYTE[EP0_CTRL] = 0x21;
 645   4            }
 646   3            else if((CTRL_Buffer[3] == 0x09)){
 647   4              SHARE_Buffer[0]=0x64;
 648   4              SHARE_Buffer[1]=0x00;
 649   4              ctrlFIFOWrite(2,SHARE_Buffer);
 650   4              XBYTE[EP0_CTRL] = 0x21;
 651   4            }
 652   3            else if((CTRL_Buffer[3] == 0x0A)){
 653   4              SHARE_Buffer[0]=0xF0;
 654   4              SHARE_Buffer[1]=0x0A;
 655   4              ctrlFIFOWrite(2,SHARE_Buffer);
 656   4              XBYTE[EP0_CTRL] = 0x21;
 657   4            }
 658   3            else if((CTRL_Buffer[3] == 0x0A)){
 659   4              SHARE_Buffer[0]=0xF0;
 660   4              SHARE_Buffer[1]=0x0A;
 661   4              ctrlFIFOWrite(2,SHARE_Buffer);
 662   4              XBYTE[EP0_CTRL] = 0x21;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 12  

 663   4            }
 664   3            else if((CTRL_Buffer[3] == 0x01) &&
 665   3              (CTRL_Buffer[4] == 0x01) && 
 666   3              (CTRL_Buffer[5] == 0x00) && 
 667   3              (CTRL_Buffer[6] == 0x1A)){
 668   4                SHARE_Buffer[0]=0x00;
 669   4                SHARE_Buffer[1]=0x00;
 670   4                SHARE_Buffer[2]=0x01;
 671   4                SHARE_Buffer[3]=0x03;
 672   4                SHARE_Buffer[4]=0x15;
 673   4                SHARE_Buffer[5]=0x16;
 674   4                SHARE_Buffer[6]=0x05;
 675   4                SHARE_Buffer[7]=0x00;
 676   4                SHARE_Buffer[8]=0x00;
 677   4                SHARE_Buffer[9]=0x00;
 678   4                SHARE_Buffer[10]=0x00;
 679   4                SHARE_Buffer[11]=0x00;
 680   4                SHARE_Buffer[12]=0x00;
 681   4                SHARE_Buffer[13]=0x00;
 682   4                SHARE_Buffer[14]=0x00;
 683   4                SHARE_Buffer[15]=0x00;
 684   4                SHARE_Buffer[16]=0x00;
 685   4                SHARE_Buffer[17]=0x00;
 686   4                SHARE_Buffer[18]=0x00;
 687   4                SHARE_Buffer[19]=0x58;
 688   4                SHARE_Buffer[20]=0x02;
 689   4                SHARE_Buffer[21]=0x00;
 690   4                SHARE_Buffer[22]=0x00;
 691   4                SHARE_Buffer[23]=0x0C;
 692   4                SHARE_Buffer[24]=0x00;
 693   4                SHARE_Buffer[25]=0x00;
 694   4                ctrlFIFOWrite(26,SHARE_Buffer); 
 695   4            }
 696   3          } // GET_MIN
 697   2          
 698   2          // GET_MAX (0x83)
 699   2          if(CTRL_Buffer[1] == USB_UVC_GET_MAX) {
 700   3            if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) {
 701   4              SHARE_Buffer[0]=0xFF;
 702   4              SHARE_Buffer[1]=0xFF;
 703   4              SHARE_Buffer[2]=0xFF;
 704   4              SHARE_Buffer[3]=0xFF;
 705   4              ctrlFIFOWrite(4,SHARE_Buffer);
 706   4              XBYTE[EP0_CTRL] = 0x21;
 707   4            }
 708   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02) && (CTRL_Buffer[3] == 0x07) )){
 709   4              SHARE_Buffer[0]=0x0A;
 710   4              SHARE_Buffer[1]=0x00;
 711   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 712   4              XBYTE[EP0_CTRL] = 0x21;
 713   4            }
 714   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && ((CTRL_Buffer[3] == 0x02 ||
 715   3            (CTRL_Buffer[3] == 0x08)))){
 716   4              SHARE_Buffer[0]=0x0A;
 717   4              SHARE_Buffer[1]=0x00;
 718   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 719   4              XBYTE[EP0_CTRL] = 0x21;
 720   4            }
 721   3            else if((CTRL_Buffer[3] == 0x04)){
 722   4              if((CTRL_Buffer[5] == 0x01)){
 723   5                SHARE_Buffer[0]=0x00;
 724   5                SHARE_Buffer[1]=0x40;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 13  

 725   5                SHARE_Buffer[2]=0x00;
 726   5                SHARE_Buffer[3]=0x00;
 727   5                ctrlFIFOWrite(4,SHARE_Buffer); 
 728   5                XBYTE[EP0_CTRL] = 0x21;
 729   5              }
 730   4              else if((CTRL_Buffer[5] == 0x02)){
 731   5                SHARE_Buffer[0]=0x30;
 732   5                SHARE_Buffer[1]=0x00;
 733   5                ctrlFIFOWrite(2,SHARE_Buffer);
 734   5                XBYTE[EP0_CTRL] = 0x21;
 735   5              }
 736   4            }
 737   3            else if((CTRL_Buffer[3] == 0x03)){
 738   4              SHARE_Buffer[0]=0x14;
 739   4              SHARE_Buffer[1]=0x00;
 740   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 741   4              XBYTE[EP0_CTRL] = 0x21;
 742   4            }
 743   3            else if((CTRL_Buffer[3] == 0x06)){
 744   4              SHARE_Buffer[0]=0x05;
 745   4              SHARE_Buffer[1]=0x00;
 746   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 747   4              XBYTE[EP0_CTRL] = 0x21;
 748   4            }
 749   3            else if((CTRL_Buffer[3] == 0x09)){
 750   4              SHARE_Buffer[0]=0xC8;
 751   4              SHARE_Buffer[1]=0x00;
 752   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 753   4              XBYTE[EP0_CTRL] = 0x21;
 754   4            }
 755   3            else if((CTRL_Buffer[3] == 0x0A)){
 756   4              SHARE_Buffer[0]=0x64;
 757   4              SHARE_Buffer[1]=0x19;
 758   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 759   4              XBYTE[EP0_CTRL] = 0x21;
 760   4            }
 761   3            else if((CTRL_Buffer[3] == 0x01)){
 762   4              if((CTRL_Buffer[5] == 0x02)){
 763   5                SHARE_Buffer[0]=0x01;
 764   5                SHARE_Buffer[1]=0x00;
 765   5                ctrlFIFOWrite(2,SHARE_Buffer);  
 766   5                XBYTE[EP0_CTRL] = 0x21;
 767   5              }
 768   4              else if( (CTRL_Buffer[4] == 0x01) && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x1A)){
 769   5                SHARE_Buffer[0]=0x00;
 770   5                SHARE_Buffer[1]=0x00;
 771   5                SHARE_Buffer[2]=0x01;
 772   5                SHARE_Buffer[3]=0x03;
 773   5                SHARE_Buffer[4]=0x15;
 774   5                SHARE_Buffer[5]=0x16;
 775   5                SHARE_Buffer[6]=0x05;
 776   5                SHARE_Buffer[7]=0x00;
 777   5                SHARE_Buffer[8]=0x00;
 778   5                SHARE_Buffer[9]=0x00;
 779   5                SHARE_Buffer[10]=0x00;
 780   5                SHARE_Buffer[11]=0x00;
 781   5                SHARE_Buffer[12]=0x00;
 782   5                SHARE_Buffer[13]=0x00;
 783   5                SHARE_Buffer[14]=0x00;
 784   5                SHARE_Buffer[15]=0x00;
 785   5                SHARE_Buffer[16]=0x00;
 786   5                SHARE_Buffer[17]=0x00;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 14  

 787   5                SHARE_Buffer[18]=0x00;
 788   5                SHARE_Buffer[19]=0x58;
 789   5                SHARE_Buffer[20]=0x02;
 790   5                SHARE_Buffer[21]=0x00;
 791   5                SHARE_Buffer[22]=0x00;
 792   5                SHARE_Buffer[23]=0x0C;
 793   5                SHARE_Buffer[24]=0x00;
 794   5                SHARE_Buffer[25]=0x00;
 795   5                ctrlFIFOWrite(26,SHARE_Buffer); 
 796   5              }
 797   4              else{
 798   5                SHARE_Buffer[0]=0xFF;
 799   5                ctrlFIFOWrite(1,SHARE_Buffer);
 800   5                XBYTE[EP0_CTRL] = 0x21;
 801   5              }
 802   4            }
 803   3            else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02)){
 804   4              SHARE_Buffer[0]=0x02;
 805   4              ctrlFIFOWrite(1,SHARE_Buffer); 
 806   4              XBYTE[EP0_CTRL] = 0x21;
 807   4            }
 808   3            else if((CTRL_Buffer[2] == 0x01)){
 809   4              SHARE_Buffer[0]=0x00;
 810   4              SHARE_Buffer[1]=0x15;
 811   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 812   4              XBYTE[EP0_CTRL] = 0x21;
 813   4            }
 814   3          } // GET MAX
 815   2          
 816   2          // GET_RES
 817   2          if(CTRL_Buffer[1] == USB_UVC_GET_RES) {
 818   3            if (((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) || ((CTRL_Buffer[5] == 0x01) && (CTRL_Buffer
             -[6] == 0x04))) {
 819   4              SHARE_Buffer[0]=0x01;
 820   4              SHARE_Buffer[1]=0x00;
 821   4              SHARE_Buffer[2]=0x00;
 822   4              SHARE_Buffer[3]=0x00;
 823   4              ctrlFIFOWrite(4,SHARE_Buffer);
 824   4              XBYTE[EP0_CTRL] = 0x21;
 825   4            }
 826   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && (CTRL_Buffer[6] == 0x02)){
 827   4              SHARE_Buffer[0]=0x01;
 828   4              SHARE_Buffer[1]=0x00;
 829   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 830   4              XBYTE[EP0_CTRL] = 0x21;
 831   4            }
 832   3            else if((CTRL_Buffer[3] == 0x01) || ((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02))){
 833   4              SHARE_Buffer[0]=0x01;
 834   4              ctrlFIFOWrite(1,SHARE_Buffer);
 835   4              XBYTE[EP0_CTRL] = 0x21; 
 836   4            }
 837   3            else if((CTRL_Buffer[2] == 0x01)){
 838   4              SHARE_Buffer[0]=0x00;
 839   4              SHARE_Buffer[1]=0x01;
 840   4              ctrlFIFOWrite(2,SHARE_Buffer);
 841   4              XBYTE[EP0_CTRL] = 0x21; 
 842   4            }
 843   3            else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01)) && (CTRL_Buffer[6] == 0x02)){
 844   4              SHARE_Buffer[0]=0x01;
 845   4              SHARE_Buffer[1]=0x00;
 846   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 847   4              XBYTE[EP0_CTRL] = 0x21;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 15  

 848   4            }
 849   3          } // GET RES
 850   2          
 851   2          // GET_DEF
 852   2          if(CTRL_Buffer[1] == USB_UVC_GET_DEF) {
 853   3            if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) {
 854   4              SHARE_Buffer[0]=0x00;
 855   4              SHARE_Buffer[1]=0x00;
 856   4              SHARE_Buffer[2]=0x00;
 857   4              SHARE_Buffer[3]=0x00;
 858   4              ctrlFIFOWrite(4,SHARE_Buffer);
 859   4              XBYTE[EP0_CTRL] = 0x21;
 860   4            }
 861   3            else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01)){
 862   4              SHARE_Buffer[0]=0x00;
 863   4              SHARE_Buffer[1]=0x02;
 864   4              SHARE_Buffer[2]=0x00;
 865   4              SHARE_Buffer[3]=0x00;
 866   4              ctrlFIFOWrite(4,SHARE_Buffer); 
 867   4              XBYTE[EP0_CTRL] = 0x21;
 868   4            }
 869   3            else if((CTRL_Buffer[3] == 0x02)){
 870   4              SHARE_Buffer[0]=0x02;
 871   4              SHARE_Buffer[1]=0x00;
 872   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 873   4              XBYTE[EP0_CTRL] = 0x21;
 874   4            }
 875   3            else if((CTRL_Buffer[3] == 0x03)){
 876   4              SHARE_Buffer[0]=0x0A;
 877   4              SHARE_Buffer[1]=0x00;
 878   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 879   4              XBYTE[EP0_CTRL] = 0x21;
 880   4            }
 881   3            else if((CTRL_Buffer[3] == 0x06)){
 882   4              SHARE_Buffer[0]=0x00;
 883   4              SHARE_Buffer[1]=0x00;
 884   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 885   4              XBYTE[EP0_CTRL] = 0x21;
 886   4            }
 887   3            else if(((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x02))){
 888   4              SHARE_Buffer[0]=0x04;
 889   4              SHARE_Buffer[1]=0x00;
 890   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 891   4              XBYTE[EP0_CTRL] = 0x21;
 892   4            }
 893   3            else if((CTRL_Buffer[3] == 0x08)){
 894   4              SHARE_Buffer[0]=0x04;
 895   4              SHARE_Buffer[1]=0x00;
 896   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 897   4              XBYTE[EP0_CTRL] = 0x21;
 898   4            } 
 899   3            else if((CTRL_Buffer[3] == 0x09)){
 900   4              SHARE_Buffer[0]=0x82;
 901   4              SHARE_Buffer[1]=0x00; 
 902   4              ctrlFIFOWrite(2,SHARE_Buffer);
 903   4              XBYTE[EP0_CTRL] = 0x21; 
 904   4            }
 905   3            else if((CTRL_Buffer[3] == 0x0A)){
 906   4              SHARE_Buffer[0]=0x64;
 907   4              SHARE_Buffer[1]=0x19;
 908   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 909   4              XBYTE[EP0_CTRL] = 0x21;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 16  

 910   4            }
 911   3            else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x02)){
 912   4              SHARE_Buffer[0]=0x01;
 913   4              SHARE_Buffer[1]=0x00;
 914   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 915   4              XBYTE[EP0_CTRL] = 0x21;
 916   4            }
 917   3            else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02)){
 918   4              SHARE_Buffer[0]=0x22;
 919   4              SHARE_Buffer[1]=0x00;
 920   4              ctrlFIFOWrite(2,SHARE_Buffer); 
 921   4              XBYTE[EP0_CTRL] = 0x21;
 922   4            }
 923   3            else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02)){
 924   4              SHARE_Buffer[0]=0x02;
 925   4              ctrlFIFOWrite(1,SHARE_Buffer);
 926   4              XBYTE[EP0_CTRL] = 0x21; 
 927   4            }
 928   3            else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x04)){
 929   4              SHARE_Buffer[0]=0x00;
 930   4              ctrlFIFOWrite(1,SHARE_Buffer); 
 931   4              XBYTE[EP0_CTRL] = 0x21;
 932   4            }
 933   3          } // GET DEF
 934   2          
 935   2          // GET_CUR
 936   2          if((CTRL_Buffer[1] == USB_UVC_GET_CUR)) {
 937   3            if((CTRL_Buffer[3] == 0x02)) {
 938   4              if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x01)){
 939   5                SHARE_Buffer[0]=0x06;
 940   5                ctrlFIFOWrite(1,SHARE_Buffer);
 941   5                XBYTE[EP0_CTRL] = 0x21;
 942   5              }
 943   4              else if((CTRL_Buffer[4] == 0x02) && (CTRL_Buffer[5] == 0x02)){
 944   5                SHARE_Buffer[0]=0x00;
 945   5                SHARE_Buffer[1]=0x0B;
 946   5                ctrlFIFOWrite(2,SHARE_Buffer);
 947   5                XBYTE[EP0_CTRL] = 0x21;
 948   5              }
 949   4              else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)){
 950   5                SHARE_Buffer[0]=0x02;
 951   5                SHARE_Buffer[1]=0x00;
 952   5                ctrlFIFOWrite(2,SHARE_Buffer);
 953   5                XBYTE[EP0_CTRL] = 0x21;
 954   5              }
 955   4              else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01)){
 956   5                SHARE_Buffer[0]=0x08;
 957   5                ctrlFIFOWrite(1,SHARE_Buffer);
 958   5                XBYTE[EP0_CTRL] = 0x21;
 959   5              }
 960   4            }
 961   3            else if(CTRL_Buffer[3] == 0x01){
 962   4              if((CTRL_Buffer[4] == 0x02)){
 963   5                SHARE_Buffer[0]=0x00;
 964   5                ctrlFIFOWrite(1,SHARE_Buffer);
 965   5                XBYTE[EP0_CTRL] = 0x21;
 966   5              }
 967   4              else if((CTRL_Buffer[4] == 0x00)) {
 968   5                SHARE_Buffer[0]=0x01;
 969   5                SHARE_Buffer[1]=0x00;
 970   5                ctrlFIFOWrite(2,SHARE_Buffer);
 971   5                XBYTE[EP0_CTRL] = 0x21;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 17  

 972   5              }
 973   4              else if((CTRL_Buffer[4] == 0x01)) {
 974   5                if (test_flag == 0){
 975   6                  for(i = 0;i < 26;i++){
 976   7                    SHARE_Buffer[i]=0x00;
 977   7                  }
 978   6                  SHARE_Buffer[2]=0x01;
 979   6                  SHARE_Buffer[3]=0x01;
 980   6                  SHARE_Buffer[4]=0x15;
 981   6                  SHARE_Buffer[5]=0x16;
 982   6                  SHARE_Buffer[6]=0x05;
 983   6                  SHARE_Buffer[19]=0x60;
 984   6                  SHARE_Buffer[20]=0x09;
 985   6                  SHARE_Buffer[22]=0x80;
 986   6                  SHARE_Buffer[23]=0x0A;
 987   6                  ctrlFIFOWrite(26,SHARE_Buffer);
 988   6                  XBYTE[EP0_CTRL] = 0x21;
 989   6                  test_flag = 1;
 990   6                }
 991   5                else{
 992   6                  for(i = 0;i < 26;i++)
 993   6                  {
 994   7                    SHARE_Buffer[i]=0x00;
 995   7                  }
 996   6                  SHARE_Buffer[2]=0x01;
 997   6                  SHARE_Buffer[3]=0x01;
 998   6                  SHARE_Buffer[4]=0x15;
 999   6                  SHARE_Buffer[5]=0x16;
1000   6                  SHARE_Buffer[6]=0x05;
1001   6                  SHARE_Buffer[19]=0x60;
1002   6                  SHARE_Buffer[20]=0x09;
1003   6                  SHARE_Buffer[22]=0x00;
1004   6                  SHARE_Buffer[23]=0x0C;
1005   6                  ctrlFIFOWrite(26,SHARE_Buffer);
1006   6                  XBYTE[EP0_CTRL] = 0x21;
1007   6                  //test_flag = 2;
1008   6                }
1009   5              }
1010   4            }
1011   3            else if(CTRL_Buffer[3] == 0x03){
1012   4              if(CTRL_Buffer[4] == 0x00){
1013   5                SHARE_Buffer[0]=0x0A;
1014   5                SHARE_Buffer[1]=0x00;
1015   5                ctrlFIFOWrite(2,SHARE_Buffer); 
1016   5                XBYTE[EP0_CTRL] = 0x21;
1017   5              }
1018   4              else if(CTRL_Buffer[4] == 0x01){
1019   5                if(test_flag == 1){
1020   6                  SHARE_Buffer[0]=0x01;
1021   6                  SHARE_Buffer[1]=0x01;
1022   6                  SHARE_Buffer[2]=0x00;
1023   6                  SHARE_Buffer[3]=0x00;
1024   6                  SHARE_Buffer[4]=0x06;
1025   6                  SHARE_Buffer[5]=0x09;
1026   6                  SHARE_Buffer[6]=0x00;
1027   6                  SHARE_Buffer[7]=0x80;
1028   6                  SHARE_Buffer[8]=0x0A;
1029   6                  SHARE_Buffer[9]=0x00;
1030   6                  SHARE_Buffer[10]=0x00;
1031   6                  ctrlFIFOWrite(11,SHARE_Buffer);
1032   6                  XBYTE[EP0_CTRL] = 0x21;
1033   6                  test_flag = 3;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 18  

1034   6                }
1035   5                else{
1036   6                  SHARE_Buffer[0]=0x01;
1037   6                  SHARE_Buffer[1]=0x01;
1038   6                  SHARE_Buffer[2]=0x00;
1039   6                  SHARE_Buffer[3]=0x00;
1040   6                  SHARE_Buffer[4]=0x06;
1041   6                  SHARE_Buffer[5]=0x09;
1042   6                  SHARE_Buffer[6]=0x00;
1043   6                  SHARE_Buffer[7]=0x00;
1044   6                  SHARE_Buffer[8]=0x0C;
1045   6                  SHARE_Buffer[9]=0x00;
1046   6                  SHARE_Buffer[10]=0x00;
1047   6                  ctrlFIFOWrite(11,SHARE_Buffer);
1048   6                  XBYTE[EP0_CTRL] = 0x21;
1049   6                }
1050   5              }
1051   4            }
1052   3            else if(CTRL_Buffer[3] == 0x06){
1053   4              SHARE_Buffer[0]=0x00;
1054   4              SHARE_Buffer[1]=0x00;
1055   4              ctrlFIFOWrite(2,SHARE_Buffer); 
1056   4              XBYTE[EP0_CTRL] = 0x21;
1057   4            }
1058   3            else if((CTRL_Buffer[3] == 0x07)){
1059   4              SHARE_Buffer[0]=0x04;
1060   4              SHARE_Buffer[1]=0x00;
1061   4              ctrlFIFOWrite(2,SHARE_Buffer); 
1062   4              XBYTE[EP0_CTRL] = 0x21;
1063   4            }
1064   3            else if((CTRL_Buffer[3] == 0x08)){
1065   4              SHARE_Buffer[0]=0x04;
1066   4              SHARE_Buffer[1]=0x00;
1067   4              ctrlFIFOWrite(2,SHARE_Buffer); 
1068   4              XBYTE[EP0_CTRL] = 0x21;
1069   4            }
1070   3            else if(CTRL_Buffer[3] == 0x09){
1071   4              SHARE_Buffer[0]=0x82;
1072   4              SHARE_Buffer[1]=0x00;
1073   4              ctrlFIFOWrite(2,SHARE_Buffer); 
1074   4              XBYTE[EP0_CTRL] = 0x21;
1075   4            }
1076   3            else if(CTRL_Buffer[3] == 0x0A){
1077   4              SHARE_Buffer[0]=0x64;
1078   4              SHARE_Buffer[1]=0x19;
1079   4              ctrlFIFOWrite(2,SHARE_Buffer);
1080   4              XBYTE[EP0_CTRL] = 0x21; 
1081   4            }
1082   3            else if(CTRL_Buffer[3] == 0x0B){
1083   4              SHARE_Buffer[0]=0x01;
1084   4              ctrlFIFOWrite(1,SHARE_Buffer); 
1085   4              XBYTE[EP0_CTRL] = 0x21;
1086   4            }
1087   3            else if(CTRL_Buffer[3] == 0x04){
1088   4              SHARE_Buffer[0]=0x00;
1089   4              SHARE_Buffer[1]=0x02;
1090   4              SHARE_Buffer[2]=0x00;
1091   4              SHARE_Buffer[3]=0x00;
1092   4              ctrlFIFOWrite(4,SHARE_Buffer); 
1093   4              XBYTE[EP0_CTRL] = 0x21;
1094   4            }
1095   3            
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 19  

1096   3          } // GET_CUR
1097   2          
1098   2          // GET_LEN
1099   2          if(CTRL_Buffer[1] == USB_UVC_GET_LEN) {
1100   3            if ((CTRL_Buffer[3] == 0x04) ||
1101   3                (CTRL_Buffer[3] == 0x05) || 
1102   3                (CTRL_Buffer[3] == 0x07) || 
1103   3                (CTRL_Buffer[3] == 0x10) ||
1104   3                (CTRL_Buffer[3] == 0x18)) {
1105   4              SHARE_Buffer[0]=0x04;
1106   4              SHARE_Buffer[1]=0x00;
1107   4              ctrlFIFOWrite(2,SHARE_Buffer);
1108   4              XBYTE[EP0_CTRL] = 0x21;
1109   4            }
1110   3            else if(CTRL_Buffer[3] == 0x01){
1111   4              SHARE_Buffer[0]=0x01;
1112   4              SHARE_Buffer[1]=0x00;
1113   4              ctrlFIFOWrite(2,SHARE_Buffer);
1114   4              XBYTE[EP0_CTRL] = 0x21; 
1115   4            }
1116   3          }// GET_LEN
1117   2          
1118   2        }
1119   1      }
1120          
1121          
1122          
1123          
1124          /*
1125          //----------------Based on Prolific 20130805-------------------//
1126          
1127          // GET_STATUS
1128          unsigned char usbGetStatus(void)
1129          {
1130            
1131          unsigned char x;
1132          
1133              if( (CTRL_Buffer[6] != 2) || (CTRL_Buffer[7] != 0) || (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) )
1134              {
1135                  XBYTE[0xFC34] = 0x23;
1136                  return( FALSE );
1137              }
1138          
1139          
1140              switch( CTRL_Buffer[0] )
1141              {
1142                      // device status
1143                  case 0x80:
1144                      if( (CTRL_Buffer[4] == 0) && (CTRL_Buffer[5] == 0) )
1145                      {
1146                          /*
1147                          if( ! busPowered ) {
1148                            x = 0x01;
1149                          }
1150                          if( RemoteWakeup ) {
1151                            x = 0x00 | 0x02;
1152                          }
1153                          *-/
1154                          
1155                      }
1156                      else
1157                      {
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 20  

1158                          XBYTE[0xFC34] = 0x23;          // endpoin stall
1159                          return( FALSE );
1160                      }
1161          
1162                      break;
1163          
1164                      // interface status
1165                  case 0x81:
1166                      x = 0x00;
1167                      break;
1168          
1169                      // endpoint status
1170                  case 0x82:
1171                      if( CTRL_Buffer[5] != 0 )
1172                      {
1173          
1174                          XBYTE[0xFC34] = 0x23;
1175                          return( FALSE );
1176                      }
1177          
1178                      switch( CTRL_Buffer[4] )
1179                      {
1180                          case 0x00:
1181                              x = XBYTE[0xFC34];
1182                              break;
1183                          case 0x81:
1184                              x = XBYTE[0xFC3C];
1185                              break;
1186          
1187                          case 0x86:
1188                              x = XBYTE[0xFC64];
1189                              break;
1190          
1191                          default:
1192          
1193                              XBYTE[0xFC64] = 0x23;
1194                              return( FALSE );
1195                      }
1196                
1197                      if( x & 0x02 )
1198                      {
1199                
1200                          x = 0x01;
1201                      }
1202                      else
1203                      {
1204              
1205                          x = 0x00;
1206                      }
1207                      break;
1208          
1209                  default:
1210          
1211                XBYTE[0xFC34] = 0x23;
1212                      return( FALSE );
1213              }
1214          
1215              XBYTE[0xF000] = x;
1216              XBYTE[0xF000+1] = 0;
1217              XBYTE[0xFC34] |= 0x21; //done
1218          
1219              return( TRUE );
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 21  

1220          }
1221          
1222          // CLEAR_FEATURE
1223          unsigned char usbClearFeature(void)
1224          {
1225              if( (CTRL_Buffer[3]) || (CTRL_Buffer[6]) || (CTRL_Buffer[7]) )
1226              {
1227                  XBYTE[0xFC34] = 0x23; 
1228                  return( FALSE );
1229              }
1230          
1231          
1232              switch( CTRL_Buffer[0] )
1233              {
1234          
1235                      // device status
1236                  case 0x00:
1237                      if( (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) )
1238                      {
1239                          XBYTE[0xFC34] = 0x23;
1240                          return( FALSE );
1241                      }
1242          
1243                      if( CTRL_Buffer[2] == DEVICE_REMOTE_WAKEUP ){
1244                          //RemoteWakeup = 0;
1245                      }
1246                      else{
1247                          XBYTE[0xFC34] = 0x23;
1248                          return( FALSE );
1249                      }
1250                      break;
1251          
1252          
1253                      // interface status
1254                  case 0x01:
1255                      XBYTE[0xFC34] = 0x23;
1256                      return( FALSE );
1257          
1258          
1259                      // endpoint status
1260                  case 0x02:
1261                      if( CTRL_Buffer[2] == ENDPOINT_HALT )
1262                      {
1263          
1264                          if( CTRL_Buffer[5] != 0 )
1265                          {
1266                              XBYTE[0xFC34] = 0x23;
1267                              return( FALSE );
1268                          }
1269          
1270                          switch( CTRL_Buffer[4] )
1271                          {
1272                              case 0x00:
1273                                  XBYTE[0xFC34] = 0x18;
1274                                  break;
1275                              case 0x81:
1276                                  XBYTE[0xFC3C] = 0x00;
1277                                  XBYTE[0xFCB0] = 0x02;//ENP_TOG_CLR_L
1278          
1279                              case 0x86:
1280                                  XBYTE[0xFC64] = 0x00;
1281                                  XBYTE[0xFCB0] = 0x40;//ENP_TOG_CLR_L
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 22  

1282                      
1283                                  break;                             
1284                              default:
1285                                  XBYTE[0xFC34] = 0x23;
1286                                  return( FALSE );
1287                          }
1288                      }
1289                      else
1290                      {
1291                          XBYTE[0xFC34] = 0x23;
1292                          return( FALSE );
1293                      }
1294          
1295                      break;
1296          
1297                  default:
1298                      XBYTE[0xFC34] = 0x23;
1299                      return( FALSE );
1300              }
1301          
1302              XBYTE[0xFC34] = 0x21;
1303              return( TRUE );
1304          }
1305          
1306          // GET_CONFIGURATION
1307          unsigned char usbGetConfig(void)
1308          {
1309              if( (CTRL_Buffer[2] == 0) || (CTRL_Buffer[3] == 0) ||
1310                      (CTRL_Buffer[4] == 0) || (CTRL_Buffer[5] == 0) ||
1311                      (CTRL_Buffer[6] == 1) || (CTRL_Buffer[7] == 0) )
1312              {
1313                if( Configed ){
1314                    XBYTE[0xF000] = 0x01;
1315                }
1316                else
1317                {
1318                    XBYTE[0xF000] = 0x00;
1319                }
1320                XBYTE[0xFC34] |= 0x21;
1321              }
1322              else
1323              {
1324                XBYTE[0xFC34] = 0x23;
1325                  return( FALSE );    
1326              }
1327            
1328              return( TRUE );
1329          }
1330          
1331          
1332          // GET_DESCRIPTOR
1333          unsigned char usbGetDescriptor(void)
1334          {
1335          unsigned char code *descp;
1336          unsigned short rlen,i;
1337          unsigned short cmd_len = 0;
1338          unsigned int  offset = 0;
1339          
1340              cmd_len = (CTRL_Buffer[7]*256 ) +  CTRL_Buffer[6];
1341          
1342              switch( CTRL_Buffer[3] )
1343              {
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 23  

1344          
1345                // Device Descriptor
1346                case 0x01:
1347          
1348                      rlen = device_desc[0];
1349                      descp = device_desc;
1350                      if( (cmd_len < rlen) )
1351                      {
1352                          rlen = CTRL_Buffer[6];
1353                      }
1354          
1355                      ctrlFIFOWrite(rlen,descp);
1356          
1357                      return( TRUE );
1358                
1359                // Configuration Descriptor & OTHER_SPEED_CONFIGURATION      
1360                case 0x02:
1361                case 0x07:
1362              
1363                      rlen = Ide_Con_Dlen;
1364                      for(i=0; i<Ide_Con_Dlen; i++)
1365                      {
1366                         SHARE_Buffer[i] = *(Con_Std_Descp+i);
1367                      }
1368          
1369                      SHARE_Buffer[1] = CTRL_Buffer[3];
1370                       
1371                      if(cmd_len == 9)
1372                      {
1373                        ctrlFIFOWrite(rlen,SHARE_Buffer); 
1374                      }
1375                      else
1376                      { 
1377                        // Configuration Descriptor Interface Descriptor
1378              
1379                        rlen = UVC_Std_Dlen+Ide_Con_Dlen;
1380                        
1381                        if( (CTRL_Buffer[3] == 0x02)  )
1382                        {
1383                            for(i=0; i<UVC_Std_Dlen; i++)
1384                            {
1385              
1386                                SHARE_Buffer[i+Ide_Con_Dlen] = *(InterfaceEP_Descp+i);
1387                            }
1388                        }
1389                        else
1390                        {
1391                            for(i=0; i<UVC_Std_Dlen; i++)
1392                            {
1393                                SHARE_Buffer[i+Ide_Con_Dlen] = *(InterfaceEP_Oth_Descp+i);
1394                            } 
1395                        }
1396                              
1397                        if( (cmd_len < rlen) )
1398                        {
1399                            rlen = cmd_len;
1400                        }
1401                    
1402                        ctrlFIFOWrite(rlen,SHARE_Buffer);
1403                      }
1404                      
1405                      return( TRUE );
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 24  

1406          
1407                      break;
1408          
1409                      // String Descriptor
1410                 case 0x03: // String Descriptor
1411                      switch( CTRL_Buffer[2] )
1412                      {
1413                          case 0x00:
1414                              rlen = Ide_Str0_Dlen;
1415                              descp = Ide_Str0_D;
1416                              if( (cmd_len < rlen) )
1417                              {
1418                                  rlen = cmd_len;
1419                              }
1420          
1421                              ctrlFIFOWrite(rlen,descp);
1422                              return( TRUE );
1423                              break;
1424                          case 0x01:
1425                              rlen = Ide_Str1_Dlen;
1426                              descp = Ide_Str1_D;
1427                              if( (cmd_len < rlen) )
1428                              {
1429                                  rlen = cmd_len;
1430                              }
1431          
1432                              ctrlFIFOWrite(rlen,descp);
1433                              return( TRUE );
1434                              break;
1435                          case 0x02:
1436          
1437                              rlen = Ide_Str2_Dlen;
1438                              descp = Ide_Str2_D;
1439                              if( (cmd_len < rlen) )
1440                              {
1441                                  rlen = cmd_len;
1442                              }
1443          
1444                              ctrlFIFOWrite(rlen,descp);
1445                              return( TRUE );
1446                              break;
1447                          case 0x03:
1448                              rlen = Ide_Str2_Dlen;
1449                              descp = Ide_Str2_D;
1450                              if( (cmd_len < rlen) )
1451                              {
1452                                  rlen = cmd_len;
1453                              }
1454          
1455                              ctrlFIFOWrite(rlen,descp);
1456                              return( TRUE );
1457                              break;
1458          
1459                          default:
1460                              goto L_GetDescpStall;
1461                       }
1462              
1463                       break;
1464                 
1465                 // Device_Qualifier Descriptor
1466                 case 0x06: 
1467                      rlen = Ide_Dvc_QF_Dlen;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 25  

1468                      descp = Ide_Dvc_QF_D;
1469                      if( (cmd_len < rlen) )
1470                      {
1471                          rlen = cmd_len;
1472                      }
1473          
1474                      ctrlFIFOWrite(rlen,descp);
1475                      return( TRUE );
1476                      break;
1477                
1478                // Interface Power Configuration  
1479                case 0x08: 
1480                    goto L_GetDescpStall;
1481                    
1482                // BOS Descriptor    
1483                case 0x0F:
1484                    rlen = 12;
1485                    descp = Ide_BOS_D;
1486                    if( (cmd_len < rlen) )
1487                    {
1488                        rlen = cmd_len;
1489                    }
1490                    ctrlFIFOWrite(rlen,descp);
1491                
1492                    return( TRUE );
1493                    break;  
1494                  break;
1495              
1496                default:
1497                  goto L_GetDescpStall;
1498              }
1499          
1500              return( TRUE );
1501          
1502          L_GetDescpStall:
1503              XBYTE[0xFC34] = 0x23;        // enpoint 0 stall
1504              return( FALSE );
1505          }
1506          
1507          
1508          // GET_INTERFACE
1509          
1510          unsigned char usbGetInterface(void)
1511          {
1512              if( (CTRL_Buffer[2] != 0) || (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 1) || (CTRL_Buffer[7] != 0) )
1513              {
1514                  XBYTE[0xFC34] = 0x23; 
1515                  return( FALSE );
1516              }
1517          
1518          
1519              if( Configed )
1520              {
1521                  XBYTE[0xF000] = SHARE_Buffer[0];
1522          
1523                  XBYTE[0xFC34] |= 0x21;
1524          
1525                  return( TRUE );
1526              }
1527              else
1528              {
1529                  return( FALSE );
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 26  

1530              }
1531          }
1532          
1533          
1534          // SET_INTERFACE
1535          unsigned char usbSetInterface(void)
1536          {
1537            if(  (CTRL_Buffer[3] != 0) ||
1538                 (CTRL_Buffer[5] != 0) ||
1539                (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) ) 
1540            {
1541                XBYTE[0xFC34] = 0x23;     
1542                return( FALSE );
1543            }
1544            else 
1545            {
1546              if( (CTRL_Buffer[0] == 0x01) && (CTRL_Buffer[1] == 0x0B) && (CTRL_Buffer[2] == 0x07) && 
1547                (CTRL_Buffer[3] == 0x00) && (CTRL_Buffer[4] == 0x01) && StartCIS1 == 1)
1548              {
1549              
1550                StartCIS1 = 0;
1551                StartCIS = 1; 
1552              }
1553          
1554              SHARE_Buffer[0] = CTRL_Buffer[2];
1555              XBYTE[0xFC64] = 0x10;
1556               
1557              XBYTE[0xFC34] |= 0x21;
1558              return( TRUE );
1559            }
1560          
1561            return( TRUE );
1562          }
1563          
1564          
1565          // SET_ADDRESS
1566          
1567          unsigned char usbSetAddress(void)
1568          {
1569              if( (CTRL_Buffer[2] & 0x80) || (CTRL_Buffer[3] != 0) ||
1570                      (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) ||
1571                      (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) )
1572              {
1573          
1574                  XBYTE[0xFC34] = 0x23;
1575                  return( FALSE );
1576              }
1577              else
1578              {
1579          
1580                  XBYTE[0xFC14] = CTRL_Buffer[2];    // Store the address to device address register
1581                  //Addressed = 1;
1582                  XBYTE[0xFC34] = 0x21;
1583                  return( TRUE );
1584          
1585              }
1586          }
1587          
1588          
1589          unsigned char usbSetConfig(void)
1590          {
1591          
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 27  

1592              if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] != 0) || (CTRL_Buffer[6] != 0) |
             -| (CTRL_Buffer[7] != 0) )
1593              {
1594                  XBYTE[0xFC34] = 0x23;
1595                  return( FALSE );
1596              }
1597          
1598              switch( CTRL_Buffer[2] )
1599              {
1600                  case 0:
1601                      Configed = 0;
1602                      XBYTE[0xFC04] = 0x01;
1603          
1604                      break;
1605          
1606                  case 1:
1607                      Configed = 1;
1608                      XBYTE[0xFC04] = 0x7F;
1609                      XBYTE[0xFC08] = 0x01;       // enable EP0 interrupt
1610                      XBYTE[0xFCB0] = 0x41;             // EP6 and EP0 toggle clear to DATA0
1611                      
1612                      break;
1613          
1614                  default:
1615                      return( FALSE );
1616              }
1617              XBYTE[0xFC64] = 0x10;
1618              XBYTE[0xFC34] |= 0x21;
1619          
1620              return( TRUE );
1621          
1622          }
1623          
1624          
1625          
1626          // SET_FEATURE
1627          
1628          unsigned char usbSetFeature(void)
1629          {
1630              if( (CTRL_Buffer[3] != 0) || (CTRL_Buffer[6] != 0) || (CTRL_Buffer[7] != 0) )
1631              {
1632                  XBYTE[0xFC34] = 0x23;
1633                  return( FALSE );
1634              }
1635          
1636              switch( CTRL_Buffer[0] )
1637              {
1638          
1639                  // device status
1640                  case 0x00:
1641                      if( CTRL_Buffer[2] == DEVICE_REMOTE_WAKEUP )
1642                      {     
1643                            RemoteWakeup = 1;
1644                      }
1645                      else if( CTRL_Buffer[2] == TEST_MODE )
1646                      {
1647                          if( (CTRL_Buffer[4] != 0) || (CTRL_Buffer[5] > 4) || (CTRL_Buffer[5] == 0) )
1648                          {
1649                              XBYTE[0xFC34] = 0x23;
1650                              return( FALSE );
1651                          }
1652          
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 28  

1653                          XBYTE[0xFC10] = CTRL_Buffer[5] | 0x08;
1654                
1655                      }
1656                      else
1657                      {
1658                          XBYTE[0xFC34] = 0x23;
1659                          return( FALSE );
1660                      }
1661          
1662                      break;
1663          
1664          
1665                   // interface status
1666                  case 0x01:
1667                      XBYTE[0xFC34] = 0x23;
1668                      return( FALSE );
1669                      
1670                  // endpoint status
1671                  case 0x02:
1672                      if( CTRL_Buffer[2] == ENDPOINT_HALT )
1673                      {
1674                          if( CTRL_Buffer[5] != 0 )
1675                          {
1676                              XBYTE[0xFC34] = 0x23;
1677                              return( FALSE );
1678                          }
1679          
1680                          switch( CTRL_Buffer[4] )
1681                          {
1682                              case 0x00:
1683                                  XBYTE[0xFC34] = 0x1A;           // EP0 flush FIFO, endpoint done
1684                              case 0x81:
1685                                  XBYTE[0xFC3C] = 0x12;           // EP1 stall
1686                                  break;
1687                              case 0x86:
1688                                  XBYTE[0xFC64] = 0x12;           // EP6 stall
1689                                  break;
1690          
1691                              default:
1692              
1693                                  XBYTE[0xFC34] = 0x23;
1694                                  return( FALSE );
1695                          }
1696                      }
1697                      else
1698                      {
1699              
1700                          XBYTE[0xFC34] = 0x23;
1701                          return( FALSE );
1702                      }
1703          
1704                      break;
1705          
1706                  default:
1707            
1708                      XBYTE[0xFC34] = 0x23;
1709                      return( FALSE );
1710              }
1711          
1712              XBYTE[0xFC34] |= 0x21;
1713              return( TRUE );
1714          }
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 29  

1715          
1716          
1717          void usb_video_class_function(void)
1718          {
1719          unsigned char UAC_len,i;
1720          
1721          
1722            UAC_len = CTRL_Buffer[6];
1723          
1724            // Host to Device
1725            if((CTRL_Buffer[0] == 0x21)) 
1726            {
1727          
1728              if ((CTRL_Buffer[1] == 0x01) && (CTRL_Buffer[2] == 0x00) && (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[4]
             - == 0x01)
1729                   && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x1A) && (CTRL_Buffer[7] == 0x00))
1730              {      
1731                 StartCIS1 = 1;
1732              }
1733             
1734            
1735              while(XBYTE[0xFC34+2] != UAC_len)
1736              {
1737                if( BusReset || (XBYTE[0xFC01] & 0x80 == 0))
1738                {
1739                  return ;
1740                }     
1741              }
1742          
1743          
1744              if (XBYTE[0xFC34+2] == UAC_len) 
1745              {
1746                    
1747                for (i=0; i<UAC_len; i++) 
1748                {
1749                   SHARE_Buffer[i] = XBYTE[0xF000+i];
1750              
1751                }
1752                
1753                if( (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x01))
1754                {
1755                  if( (SHARE_Buffer[0] != 0x01) && (SHARE_Buffer[0] != 0x08) )
1756                  {
1757                    XBYTE[0xFCB2] |= 0x01;
1758                    SHARE_Buffer[0] = 0x04;               
1759                    XBYTE[0xFC34] |= 0x04;   //flush FIFO
1760                    XBYTE[0xFC34] = 0x23;    // EP0 stall   
1761                  }
1762                  else
1763                  {     
1764                    XBYTE[0xFCB2] |= 0x01;
1765                    XBYTE[0xFC34] |= 0x04; //flush
1766                    XBYTE[0xFC34] = 0x21;         
1767                  }
1768                }
1769                else
1770                {
1771          
1772                  XBYTE[0xFCB2] |= 0x01;  //ENP_Interrupt_Restore_L
1773                  XBYTE[0xFC34] |= 0x04; //flush
1774                  XBYTE[0xFC34] = 0x21;       
1775                }     
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 30  

1776          
1777              }
1778            } 
1779            
1780            // Device to Host
1781            else if((CTRL_Buffer[0] == 0xA1)) 
1782            {
1783              if(UAC_len ==0) {
1784                  XBYTE[0xFC34] = 0x21;
1785              }
1786            
1787              // GET_INFO
1788              if(CTRL_Buffer[1] == 0x86) 
1789              {
1790                if((CTRL_Buffer[3] == 0x03) || (CTRL_Buffer[3] == 0x06) || (CTRL_Buffer[3] == 0x08)||
1791                    ((CTRL_Buffer[3] == 0x09) && (CTRL_Buffer[5] == 0x02))|| (CTRL_Buffer[3] == 0x01) || (CTRL_Buffer[
             -3] == 0x05) ||
1792                    (CTRL_Buffer[3] == 0x10) || (CTRL_Buffer[3] == 0x18) || ((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5
             -] == 0x02))||
1793                    ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02)) || ((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer
             -[5] == 0x04))) 
1794                {
1795                  
1796                    SHARE_Buffer[0]=0x03;
1797                    ctrlFIFOWrite(1,SHARE_Buffer);          
1798                }
1799                else if( (CTRL_Buffer[3] == 0x02) )
1800                {
1801          
1802                    SHARE_Buffer[0]=0x03;
1803                    ctrlFIFOWrite(1,SHARE_Buffer);        
1804                }
1805          
1806                else if( ( (CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01) ) )
1807                {
1808              
1809                    SHARE_Buffer[0]=0x0F;
1810                    ctrlFIFOWrite(1,SHARE_Buffer); 
1811                }
1812                else if((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x04))
1813                {   
1814                    SHARE_Buffer[0]=0x01;
1815                    ctrlFIFOWrite(1,SHARE_Buffer); 
1816                }
1817                else
1818                {
1819                    XBYTE[0xFC34] = 0x23; 
1820                }
1821          
1822               
1823              }   //577 if
1824          
1825              
1826              //GET_MIN
1827              if(CTRL_Buffer[1] == 0x82) 
1828              {
1829                  if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) 
1830                  {
1831                  
1832                    SHARE_Buffer[0]=0x00;
1833                    SHARE_Buffer[1]=0x00;
1834                    SHARE_Buffer[2]=0x00;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 31  

1835                    SHARE_Buffer[3]=0x00;
1836                    ctrlFIFOWrite(4,SHARE_Buffer);
1837                  }
1838          
1839                  else if(((CTRL_Buffer[3] == 0x03) || (CTRL_Buffer[3] == 0x07) || (CTRL_Buffer[3] == 0x08) || (CTRL_Bu
             -ffer[3] == 0x01)) &&
1840                       (CTRL_Buffer[5] == 0x02))
1841                  {
1842              
1843                    SHARE_Buffer[0]=0x00;
1844                    SHARE_Buffer[1]=0x00;
1845                    ctrlFIFOWrite(2,SHARE_Buffer); 
1846                  }
1847          
1848                  else if(((CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x01)) && (CTRL_Buffer[6] == 0x01))
1849                  {
1850              
1851                    SHARE_Buffer[0]=0x00;
1852                    ctrlFIFOWrite(1,SHARE_Buffer); 
1853                  }
1854          
1855                  else if((CTRL_Buffer[3] == 0x04))
1856                  {
1857                    if((CTRL_Buffer[5] == 0x01))
1858                    {
1859          
1860                      SHARE_Buffer[0]=0x08;
1861                      SHARE_Buffer[1]=0x00;
1862                      SHARE_Buffer[2]=0x00;
1863                      SHARE_Buffer[3]=0x00;
1864                      ctrlFIFOWrite(4,SHARE_Buffer);
1865                    }
1866                    else
1867                    {
1868                  
1869                      SHARE_Buffer[0]=0x20;
1870                      SHARE_Buffer[1]=0x00;
1871                      ctrlFIFOWrite(2,SHARE_Buffer);     
1872                    }          
1873                  }
1874          
1875                  else if((CTRL_Buffer[3] == 0x02))
1876                  {
1877                    if((CTRL_Buffer[2] == 0x00))
1878                    {
1879                      if(CTRL_Buffer[6] == 0x02)
1880                      {        
1881                        SHARE_Buffer[0]=0xF6;
1882                        SHARE_Buffer[1]=0xFF;
1883                        ctrlFIFOWrite(2,SHARE_Buffer);
1884                      }
1885                      else if(CTRL_Buffer[5] == 0x01)
1886                      {
1887                        SHARE_Buffer[0]=0x07;
1888                        XBYTE[0xFC34] = 0x23;
1889                      }
1890                    }
1891                    else 
1892                    {
1893          
1894                      SHARE_Buffer[0]=0x00;
1895                      SHARE_Buffer[1]=0xE5;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 32  

1896                      ctrlFIFOWrite(2,SHARE_Buffer);
1897                    }
1898              
1899                  }
1900          
1901                  else if((CTRL_Buffer[3] == 0x06))
1902                  {
1903                     
1904                    SHARE_Buffer[0]=0xFB;
1905                    SHARE_Buffer[1]=0xFF;
1906                    ctrlFIFOWrite(2,SHARE_Buffer);
1907                  }
1908          
1909                  else if((CTRL_Buffer[3] == 0x09))
1910                  {
1911                     
1912                    SHARE_Buffer[0]=0x64;
1913                    SHARE_Buffer[1]=0x00;
1914                    ctrlFIFOWrite(2,SHARE_Buffer);
1915                  }
1916          
1917                  else if((CTRL_Buffer[3] == 0x0A))
1918                  {
1919                     
1920                    SHARE_Buffer[0]=0xF0;
1921                    SHARE_Buffer[1]=0x0A;
1922                    ctrlFIFOWrite(2,SHARE_Buffer);
1923                  }
1924          
1925                  else if((CTRL_Buffer[3] == 0x0A))
1926                  {
1927                     
1928                    SHARE_Buffer[0]=0xF0;
1929                    SHARE_Buffer[1]=0x0A;
1930                    ctrlFIFOWrite(2,SHARE_Buffer);
1931                  }
1932                  else if( (CTRL_Buffer[3] == 0x01) )
1933                  {
1934                      for(i = 0;i < 26;i++)
1935                      {
1936                          SHARE_Buffer[i]=0x00;
1937                      }
1938                      
1939                      if(test_flag == 1)
1940                      {
1941                        SHARE_Buffer[2]=0x01;
1942                        SHARE_Buffer[3]=0x01;
1943                        SHARE_Buffer[4]=0x15;
1944                        SHARE_Buffer[5]=0x16;
1945                        SHARE_Buffer[6]=0x05;
1946                        SHARE_Buffer[19]=0x60;
1947                        SHARE_Buffer[20]=0x09;
1948                        SHARE_Buffer[22]=0x00;
1949                        SHARE_Buffer[23]=0x0C;            
1950                      }
1951                      else
1952                      {
1953                        SHARE_Buffer[2]=0x01;
1954                        SHARE_Buffer[3]=0x01;
1955                        SHARE_Buffer[4]=0x15;
1956                        SHARE_Buffer[5]=0x16;
1957                        SHARE_Buffer[6]=0x05;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 33  

1958                        SHARE_Buffer[19]=0x60;
1959                        SHARE_Buffer[20]=0x09;
1960                        SHARE_Buffer[22]=0x80;
1961                        SHARE_Buffer[23]=0x0A;
1962                      }
1963                        ctrlFIFOWrite(26,SHARE_Buffer); 
1964                  }
1965          
1966              }  
1967          
1968              // GET_MAX
1969              if(CTRL_Buffer[1] == 0x83) 
1970              {
1971                  if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) 
1972                  {
1973                  
1974                    SHARE_Buffer[0]=0xFF;
1975                    SHARE_Buffer[1]=0xFF;
1976                    SHARE_Buffer[2]=0xFF;
1977                    SHARE_Buffer[3]=0xFF;
1978                    ctrlFIFOWrite(4,SHARE_Buffer);
1979                  }
1980          
1981                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02) && (CTRL_Buffer[3] == 0x07) ))
1982                  {
1983              
1984                    SHARE_Buffer[0]=0x0A;
1985                    SHARE_Buffer[1]=0x00;
1986                    ctrlFIFOWrite(2,SHARE_Buffer); 
1987              
1988                  }
1989                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && ((CTRL_Buffer[3] == 0x02 ||
1990                        (CTRL_Buffer[3] == 0x08))))
1991                  {
1992              
1993                    SHARE_Buffer[0]=0x0A;
1994                    SHARE_Buffer[1]=0x00;
1995                    ctrlFIFOWrite(2,SHARE_Buffer); 
1996              
1997                  }
1998          
1999                  else if((CTRL_Buffer[3] == 0x04))
2000                  {
2001                    if((CTRL_Buffer[5] == 0x01))
2002                    {
2003                 
2004                      SHARE_Buffer[0]=0x00;
2005                      SHARE_Buffer[1]=0x40;
2006                      SHARE_Buffer[2]=0x00;
2007                      SHARE_Buffer[3]=0x00;
2008                      ctrlFIFOWrite(4,SHARE_Buffer); 
2009                    }
2010                    else if((CTRL_Buffer[5] == 0x02))
2011                    {
2012                   
2013                      SHARE_Buffer[0]=0x30;
2014                      SHARE_Buffer[1]=0x00;
2015                      ctrlFIFOWrite(2,SHARE_Buffer);
2016                 
2017                    }
2018                        
2019                  }
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 34  

2020          
2021                  else if((CTRL_Buffer[3] == 0x03))
2022                  {
2023              
2024                    SHARE_Buffer[0]=0x14;
2025                    SHARE_Buffer[1]=0x00;
2026                    ctrlFIFOWrite(2,SHARE_Buffer); 
2027                  }
2028          
2029                  else if((CTRL_Buffer[3] == 0x06))
2030                  {
2031              
2032                    SHARE_Buffer[0]=0x05;
2033                    SHARE_Buffer[1]=0x00;
2034                    ctrlFIFOWrite(2,SHARE_Buffer); 
2035                  }
2036          
2037                  else if((CTRL_Buffer[3] == 0x09))
2038                  {
2039              
2040                    SHARE_Buffer[0]=0xC8;
2041                    SHARE_Buffer[1]=0x00;
2042                    ctrlFIFOWrite(2,SHARE_Buffer); 
2043                  }
2044          
2045                  else if((CTRL_Buffer[3] == 0x0A))
2046                  {   
2047                    SHARE_Buffer[0]=0x64;
2048                    SHARE_Buffer[1]=0x19;
2049                    ctrlFIFOWrite(2,SHARE_Buffer); 
2050                  }
2051          
2052                  else if((CTRL_Buffer[3] == 0x01))
2053                  {
2054              
2055                    if((CTRL_Buffer[5] == 0x02))
2056                    {
2057                   
2058                      SHARE_Buffer[0]=0x01;
2059                      SHARE_Buffer[1]=0x00;
2060                      ctrlFIFOWrite(2,SHARE_Buffer);  
2061                    }
2062                    else if( (CTRL_Buffer[4] == 0x01) )  
2063                    {
2064                      for(i = 0;i < 26;i++)
2065                      {
2066                          SHARE_Buffer[i]=0x00;
2067                      }
2068                      
2069                      if(test_flag == 1)
2070                      {
2071                        SHARE_Buffer[2]=0x01;
2072                        SHARE_Buffer[3]=0x01;
2073                        SHARE_Buffer[4]=0x15;
2074                        SHARE_Buffer[5]=0x16;
2075                        SHARE_Buffer[6]=0x05;
2076                        SHARE_Buffer[19]=0x60;
2077                        SHARE_Buffer[20]=0x09;
2078                        SHARE_Buffer[22]=0x00;
2079                        SHARE_Buffer[23]=0x0C;            
2080                      }
2081                      else
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 35  

2082                      {
2083                        SHARE_Buffer[2]=0x01;
2084                        SHARE_Buffer[3]=0x01;
2085                        SHARE_Buffer[4]=0x15;
2086                        SHARE_Buffer[5]=0x16;
2087                        SHARE_Buffer[6]=0x05;
2088                        SHARE_Buffer[19]=0x60;
2089                        SHARE_Buffer[20]=0x09;
2090                        SHARE_Buffer[22]=0x80;
2091                        SHARE_Buffer[23]=0x0A;          
2092                      }
2093          
2094                        ctrlFIFOWrite(26,SHARE_Buffer); 
2095                    }
2096                    else
2097                    {
2098                   
2099                        SHARE_Buffer[0]=0xFF;
2100                        ctrlFIFOWrite(1,SHARE_Buffer);
2101                    }
2102                      
2103              
2104                  }
2105          
2106                  else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02))
2107                  {
2108              
2109                     SHARE_Buffer[0]=0x02;
2110                     ctrlFIFOWrite(1,SHARE_Buffer); 
2111                  }
2112          
2113                  else if((CTRL_Buffer[2] == 0x01))
2114                  {
2115              
2116                     SHARE_Buffer[0]=0x00;
2117                     SHARE_Buffer[1]=0x15;
2118                     ctrlFIFOWrite(2,SHARE_Buffer); 
2119                  }
2120                  else if( (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x00) & (CTRL_Buffer[4] == 0x00))
2121                  {
2122                     SHARE_Buffer[0]=0x07;
2123                     XBYTE[0xFC34] = 0x23;
2124                  }
2125                  else
2126                  { 
2127                     XBYTE[0xFC34] = 0x23;  
2128                        
2129                  }
2130          
2131              }  // end GET_MAX
2132          
2133          
2134              // GET_RES
2135              if(CTRL_Buffer[1] == 0x84) 
2136              {
2137                  if (((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) || ((CTRL_Buffer[5] == 0x01) && (CTRL_B
             -uffer[6] == 0x04))) 
2138                  {
2139                  
2140                    SHARE_Buffer[0]=0x01;
2141                    SHARE_Buffer[1]=0x00;
2142                    SHARE_Buffer[2]=0x00;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 36  

2143                    SHARE_Buffer[3]=0x00;
2144                    ctrlFIFOWrite(4,SHARE_Buffer);
2145                  }
2146          
2147                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02)) && (CTRL_Buffer[6] == 0x02))
2148                  {
2149              
2150                    SHARE_Buffer[0]=0x01;
2151                    SHARE_Buffer[1]=0x00;
2152                    ctrlFIFOWrite(2,SHARE_Buffer); 
2153              
2154                  }
2155          
2156                  else if((CTRL_Buffer[3] == 0x01) || ((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02)))
2157                  {
2158              
2159                    SHARE_Buffer[0]=0x01;
2160                    ctrlFIFOWrite(1,SHARE_Buffer);
2161                  }
2162          
2163                  else if((CTRL_Buffer[2] == 0x01))
2164                  {
2165              
2166                    SHARE_Buffer[0]=0x00;
2167                    SHARE_Buffer[1]=0x01;
2168                    ctrlFIFOWrite(2,SHARE_Buffer);
2169                  }
2170          
2171                  else if(((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01)) && (CTRL_Buffer[6] == 0x02))
2172                  {
2173              
2174                    SHARE_Buffer[0]=0x01;
2175                    SHARE_Buffer[1]=0x00;
2176                    ctrlFIFOWrite(2,SHARE_Buffer); 
2177                  }
2178                  else if(((CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x01)) && ( (CTRL_Buffer[6] == 0x01) || (CTRL
             -_Buffer[6] == 0x04) ) )
2179                  {
2180              
2181                    SHARE_Buffer[0]=0x09;
2182                    ctrlFIFOWrite(1,SHARE_Buffer); 
2183                  }
2184              } //  end GET_RES
2185          
2186          
2187              // GET_DEF
2188              if(CTRL_Buffer[1] == 0x87) 
2189              {
2190                if ((CTRL_Buffer[5] == 0x04) && (CTRL_Buffer[6] == 0x04)) 
2191                {
2192                  
2193                  SHARE_Buffer[0]=0x00;
2194                  SHARE_Buffer[1]=0x00;
2195                  SHARE_Buffer[2]=0x00;
2196                  SHARE_Buffer[3]=0x00;
2197                  ctrlFIFOWrite(4,SHARE_Buffer);
2198                }
2199          
2200                else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01))
2201                {
2202              
2203                  SHARE_Buffer[0]=0x00;
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 37  

2204                  SHARE_Buffer[1]=0x02;
2205                  SHARE_Buffer[2]=0x00;
2206                  SHARE_Buffer[3]=0x00;
2207                  ctrlFIFOWrite(4,SHARE_Buffer); 
2208                }
2209          
2210                else if((CTRL_Buffer[3] == 0x02))
2211                {
2212                  if(CTRL_Buffer[6] == 0x02)
2213                  { 
2214                     SHARE_Buffer[0]=0x02;
2215                     SHARE_Buffer[1]=0x00;
2216                     ctrlFIFOWrite(2,SHARE_Buffer); 
2217                  }
2218                  else if(CTRL_Buffer[6] == 0x01)
2219                  {
2220                     SHARE_Buffer[0]=0x08;
2221                     ctrlFIFOWrite(1,SHARE_Buffer); 
2222                  }
2223                }
2224          
2225                else if((CTRL_Buffer[3] == 0x03))
2226                {
2227              
2228                  SHARE_Buffer[0]=0x0A;
2229                  SHARE_Buffer[1]=0x00;
2230                  ctrlFIFOWrite(2,SHARE_Buffer); 
2231                }
2232          
2233                else if((CTRL_Buffer[3] == 0x06))
2234                {
2235              
2236                  SHARE_Buffer[0]=0x00;
2237                  SHARE_Buffer[1]=0x00;
2238                  ctrlFIFOWrite(2,SHARE_Buffer); 
2239                }
2240          
2241                else if(((CTRL_Buffer[3] == 0x07) && (CTRL_Buffer[5] == 0x02)))
2242                {
2243              
2244                  SHARE_Buffer[0]=0x04;
2245                  SHARE_Buffer[1]=0x00;
2246                  ctrlFIFOWrite(2,SHARE_Buffer); 
2247                }
2248          
2249                else if((CTRL_Buffer[3] == 0x08))
2250                {
2251              
2252                  SHARE_Buffer[0]=0x04;
2253                  SHARE_Buffer[1]=0x00;
2254                  ctrlFIFOWrite(2,SHARE_Buffer); 
2255                } 
2256          
2257                else if((CTRL_Buffer[3] == 0x09))
2258                {
2259              
2260                  SHARE_Buffer[0]=0x82;
2261                  SHARE_Buffer[1]=0x00; 
2262                  ctrlFIFOWrite(2,SHARE_Buffer);
2263                }
2264          
2265                else if((CTRL_Buffer[3] == 0x0A))
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 38  

2266                {
2267              
2268                  SHARE_Buffer[0]=0x64;
2269                  SHARE_Buffer[1]=0x19;
2270                  ctrlFIFOWrite(2,SHARE_Buffer); 
2271                }
2272          
2273                else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x02))
2274                {
2275              
2276                  SHARE_Buffer[0]=0x01;
2277                  SHARE_Buffer[1]=0x00;
2278                  ctrlFIFOWrite(2,SHARE_Buffer); 
2279                }
2280          
2281                else if((CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x02))
2282                { 
2283                  SHARE_Buffer[0]=0x22;
2284                  SHARE_Buffer[1]=0x00;
2285                  ctrlFIFOWrite(2,SHARE_Buffer); 
2286                }
2287          
2288                else if((CTRL_Buffer[3] == 0x05) && (CTRL_Buffer[5] == 0x02))
2289                {
2290              
2291                  SHARE_Buffer[0]=0x02;
2292                  ctrlFIFOWrite(1,SHARE_Buffer);
2293                }
2294          
2295                else if((CTRL_Buffer[3] == 0x01) && (CTRL_Buffer[5] == 0x04))
2296                {
2297                  SHARE_Buffer[0]=0x00;
2298                  ctrlFIFOWrite(1,SHARE_Buffer); 
2299                }
2300              } // end GET_DEF
2301          
2302              // GET_CUR
2303              if((CTRL_Buffer[1] == 0x81)) 
2304              {
2305                if((CTRL_Buffer[3] == 0x02)) 
2306                {
2307                  if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x00) && (CTRL_Buffer[6] == 0x01))
2308                  {  // Request error code control
2309                
2310                    ctrlFIFOWrite(1,SHARE_Buffer);
2311                
2312                  }
2313          
2314                  else if((CTRL_Buffer[4] == 0x02) && (CTRL_Buffer[5] == 0x02))
2315                  {
2316                 
2317                    SHARE_Buffer[0]=0x00;
2318                    SHARE_Buffer[1]=0x0B;
2319                    ctrlFIFOWrite(2,SHARE_Buffer);
2320                  }
2321          
2322                  else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x02))
2323                  {
2324                  
2325                    SHARE_Buffer[0]=0x06;
2326                    XBYTE[0xFC34] = 0x23;
2327                  }
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 39  

2328                  
2329                  else if((CTRL_Buffer[4] == 0x00) && (CTRL_Buffer[5] == 0x01))
2330                  {
2331                    SHARE_Buffer[0]=0x06;
2332                    XBYTE[0xFC34] = 0x23;         
2333                  }
2334                }
2335          
2336                else if(CTRL_Buffer[3] == 0x01)
2337                {
2338          
2339                  if((CTRL_Buffer[4] == 0x02))
2340                  {
2341                 
2342                    SHARE_Buffer[0]=0x00;
2343                    ctrlFIFOWrite(1,SHARE_Buffer);
2344                  }
2345              
2346                  else if( (CTRL_Buffer[4] == 0x00) && ( (CTRL_Buffer[5] == 0x01) || (CTRL_Buffer[5] == 0x02) ) ) 
2347                  {
2348                    SHARE_Buffer[0]=0x06;
2349                    XBYTE[0xFC34] = 0x23;
2350                  }
2351          
2352                  else if((CTRL_Buffer[4] == 0x01)) 
2353                  {
2354                     
2355                    if (test_flag == 0)
2356                    {
2357                      for(i = 0;i < 26;i++)
2358                      {
2359                          SHARE_Buffer[i]=0x00;
2360                      }
2361                      SHARE_Buffer[2]=0x01;
2362                      SHARE_Buffer[3]=0x01;
2363                      SHARE_Buffer[4]=0x15;
2364                      SHARE_Buffer[5]=0x16;
2365                      SHARE_Buffer[6]=0x05;
2366                      SHARE_Buffer[19]=0x60;
2367                      SHARE_Buffer[20]=0x09;
2368                      SHARE_Buffer[22]=0x80;
2369                      SHARE_Buffer[23]=0x0A;
2370                      ctrlFIFOWrite(26,SHARE_Buffer);
2371                      test_flag = 1;
2372                    }       
2373                    else
2374                    {
2375                      for(i = 0;i < 26;i++)
2376                      {
2377                          SHARE_Buffer[i]=0x00;
2378                      }
2379                      SHARE_Buffer[2]=0x01;
2380                      SHARE_Buffer[3]=0x01;
2381                      SHARE_Buffer[4]=0x15;
2382                      SHARE_Buffer[5]=0x16;
2383                      SHARE_Buffer[6]=0x05;
2384                      SHARE_Buffer[19]=0x60;
2385                      SHARE_Buffer[20]=0x09;
2386                      SHARE_Buffer[22]=0x00;
2387                      SHARE_Buffer[23]=0x0C;
2388                      ctrlFIFOWrite(26,SHARE_Buffer);
2389                    }
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 40  

2390                   
2391                  }
2392              
2393                }
2394          
2395                else if(CTRL_Buffer[3] == 0x03)
2396                {
2397                    if(CTRL_Buffer[4] == 0x00)
2398                    {
2399                      SHARE_Buffer[0]=0x06;
2400                      XBYTE[0xFC34] = 0x23;
2401                    }
2402          
2403                    else if(CTRL_Buffer[4] == 0x01)
2404                    {
2405                      if(test_flag == 1)
2406                      {
2407                        SHARE_Buffer[0]=0x01;
2408                        SHARE_Buffer[1]=0x01;
2409                        SHARE_Buffer[2]=0x00;
2410                        SHARE_Buffer[3]=0x00;
2411                        SHARE_Buffer[4]=0x06;
2412                        SHARE_Buffer[5]=0x09;
2413                        SHARE_Buffer[6]=0x00;
2414                        SHARE_Buffer[7]=0x80;
2415                        SHARE_Buffer[8]=0x0A;
2416                        SHARE_Buffer[9]=0x00;
2417                        SHARE_Buffer[10]=0x00;
2418                        ctrlFIFOWrite(11,SHARE_Buffer);
2419                        test_flag = 3;
2420                      }
2421          
2422                      else
2423                      {
2424                        SHARE_Buffer[0]=0x01;
2425                        SHARE_Buffer[1]=0x01;
2426                        SHARE_Buffer[2]=0x00;
2427                        SHARE_Buffer[3]=0x00;
2428                        SHARE_Buffer[4]=0x06;
2429                        SHARE_Buffer[5]=0x09;
2430                        SHARE_Buffer[6]=0x00;
2431                        SHARE_Buffer[7]=0x00;
2432                        SHARE_Buffer[8]=0x0C;
2433                        SHARE_Buffer[9]=0x00;
2434                        SHARE_Buffer[10]=0x00;
2435                        ctrlFIFOWrite(11,SHARE_Buffer);
2436                      }
2437                    }
2438                    
2439              
2440                }
2441          
2442                else if( (CTRL_Buffer[3] == 0x04) || (CTRL_Buffer[3] == 0x0C) || (CTRL_Buffer[3] == 0x0F) ||
2443                     (CTRL_Buffer[3] == 0x10) || (CTRL_Buffer[3] == 0x0D) || (CTRL_Buffer[3] == 0x0E) ||
2444                               (CTRL_Buffer[3] == 0x11) || (CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x12) ||
2445                     (CTRL_Buffer[3] == 0x0B) || (CTRL_Buffer[3] == 0x0A) || (CTRL_Buffer[3] == 0x09) ||
2446                     (CTRL_Buffer[3] == 0x08) || (CTRL_Buffer[3] == 0x07) || (CTRL_Buffer[3] == 0x06) )
2447                {
2448                    SHARE_Buffer[0]=0x06;
2449                    XBYTE[0xFC34] = 0x23;
2450                    
2451                }
C51 COMPILER V9.00   USBLIBPRO                                                             01/22/2014 12:07:45 PAGE 41  

2452          
2453              }  // end GET_CUR
2454          
2455              
2456              
2457              // GET_LEN
2458              if(CTRL_Buffer[1] == 0x85) 
2459              {
2460                if ( (CTRL_Buffer[3] == 0x05) || (CTRL_Buffer[3] == 0x07) || (CTRL_Buffer[3] == 0x10) ||
2461                      (CTRL_Buffer[3] == 0x18)) 
2462                {
2463                  
2464                  SHARE_Buffer[0]=0x04;
2465                  SHARE_Buffer[1]=0x00;
2466                  ctrlFIFOWrite(2,SHARE_Buffer);
2467                }
2468                else if( (CTRL_Buffer[3] == 0x04) && (CTRL_Buffer[5] == 0x01) && (CTRL_Buffer[6] == 0x04))
2469                {
2470                  SHARE_Buffer[0]=0x07;
2471                  XBYTE[0xFC34] = 0x23;       
2472                }
2473          
2474                else if(CTRL_Buffer[3] == 0x01)
2475                {
2476              
2477                  SHARE_Buffer[0]=0x01;
2478                  SHARE_Buffer[1]=0x00;
2479                  ctrlFIFOWrite(2,SHARE_Buffer);
2480              
2481                }
2482                else if( (CTRL_Buffer[3] == 0x02) && (CTRL_Buffer[5] == 0x01))
2483                {
2484                  SHARE_Buffer[0]=0x07;
2485                  XBYTE[0xFC34] = 0x23;
2486                }
2487                else
2488                {
2489                  XBYTE[0xFC34] = 0x23; 
2490                }
2491          
2492              }  // end GET_LEN
2493            }
2494          }   // end usb_video_class_function()
2495          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3695    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
