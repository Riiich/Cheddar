C51 COMPILER V9.00   USBAPI                                                                01/16/2014 17:12:00 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE USBAPI
OBJECT MODULE PLACED IN .\bin\UsbApi.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\UsbApi.c BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\UsbApi.lst) TABS(2) OBJE
                    -CT(.\bin\UsbApi.obj)

line level    source

   1          #include "platform.h"
   2          
   3          void InitUsb2()
   4          {
   5   1        XBYTE[0xFC00] |= 0x10 ;    // USB Soft Reset
   6   1        _nop_();_nop_();_nop_();_nop_();
   7   1          _nop_();_nop_();_nop_();
   8   1      
   9   1        //end-point 0 setting
  10   1          XBYTE[0xFC32] = 0x03;   // EP0 control endpoint,  packet size 64 bytes 
  11   1          XBYTE[0xFC34] = 0x20;   // Control register setting, interrupt happens when packet of data is received.
             -  
  12   1      
  13   1        //end-point 6 setting
  14   1          XBYTE[0xFC61] |= 0x10;    // enable maximum packet size
  15   1          XBYTE[0xFC62] = 0xA6;   // ISO In, packet size = 1024 bytes
  16   1          XBYTE[0xFC64] = 0x10;
  17   1      
  18   1        //------------FIFO SIZE SETTING--------------------
  19   1        XBYTE[EP1_FIFO_SIZE_REG]= 0x00; 
  20   1        XBYTE[EP2_FIFO_SIZE_REG]= 0x00;
  21   1        XBYTE[EP3_FIFO_SIZE_REG]= 0x00;
  22   1        XBYTE[EP4_FIFO_SIZE_REG]= 0x00;
  23   1        XBYTE[EP5_FIFO_SIZE_REG]= 0x00;
  24   1        XBYTE[EP6_FIFO_SIZE_REG]= 0x80;
  25   1        XBYTE[EP7_FIFO_SIZE_REG]= 0x00;
  26   1        XBYTE[EP8_FIFO_SIZE_REG]= 0x00;
  27   1        XBYTE[EP9_FIFO_SIZE_REG]= 0x00;
  28   1        XBYTE[EP10_FIFO_SIZE_REG]= 0x00;
  29   1        XBYTE[EP11_FIFO_SIZE_REG]= 0x00;
  30   1        XBYTE[EP12_FIFO_SIZE_REG]= 0x00;
  31   1        XBYTE[EP13_FIFO_SIZE_REG]= 0x00;
  32   1        XBYTE[EP14_FIFO_SIZE_REG]= 0x00;
  33   1        XBYTE[EP15_FIFO_SIZE_REG]= 0x00;
  34   1      
  35   1      
  36   1        //Sync FIFO
  37   1        XBYTE[0xFD8B] |=0x06;   // Choose the FIFO of endpoint 6 to be the input data buffer of CIS
  38   1      
  39   1        //---Initial global variables---
  40   1        VbusInt = 0;
  41   1        BusReset = 0;
  42   1        BusSuspend = 0;
  43   1        BusResume = 0;
  44   1        PktRcv = 0;
  45   1        BulkOutRcv = 0;
  46   1        Abort = 0;
  47   1      
  48   1        XBYTE[0xFF10] |= 0x02;    // enable resume pin
  49   1        XBYTE[0xFC04] = 0xFF;   // enable ALL endpoint buffer
  50   1        XBYTE[0xFC08] = 0xFF;   // enable ALL endpoint interrupts
  51   1        XBYTE[0xFC06] = 0x0F;   // enable BusSuspend, BusResume, BusReset and VbusInt interrupts
  52   1        
  53   1      }
C51 COMPILER V9.00   USBAPI                                                                01/16/2014 17:12:00 PAGE 2   

  54          
  55          void UpdateUSB()
  56          {
  57   1        InitUsb2();
  58   1      START:
  59   1        
  60   1        while( (XBYTE[0xFC01] & 0x80) != 0x80 );  // check if any external USB VBUS pin input
  61   1        XBYTE[0xFC00] =  0x01 | 0x08;             // Attach device to USB bus and enable the global control of USB inte
             -rrupt 
  62   1        
  63   1        while (0xFF) {
  64   2          
  65   2          if(_testbit_(BusReset)){
  66   3            //InitUsb2();
  67   3            P2_3=0;
  68   3          }
  69   2          if (BusSuspend) {
  70   3            BusSuspend=0;
  71   3            P2_4=0;
  72   3          }
  73   2          if(_testbit_(BusResume)) {
  74   3            P2_5=0;
  75   3          }
  76   2          if(_testbit_(PktRcv)){
  77   3      //      controlCMD();
  78   3          }
  79   2      /*
  80   2          if(DS_USB_VBUS_DETACH){
  81   2            goto START;
  82   2          }
  83   2      /*
  84   2          if(GLOBAL_test) {
  85   2            GLOBAL_test = 0;
  86   2            ISO_TEST_1();
  87   2          }
  88   2          */
  89   2        }
  90   1      
  91   1      }
*** WARNING C280 IN LINE 58 OF SRC\USBAPI.C: 'START': unreferenced label
  92          
  93          
  94          // Endpoint 0 FIFO Read 
  95          unsigned char ctrlFIFORead(/*unsigned int len, */unsigned char *buf )
  96          {
  97   1        unsigned int  j;
  98   1      
  99   1          // read out the 8-byte control data from endpoint 0 FIFO to user defined buffer
 100   1          for( j=0; j<8; j++ ){
 101   2            buf[j] = XBYTE[0xF000+j];
 102   2      
 103   2          }
 104   1         
 105   1          // If there are not any data following this control transfer, restore EP0 interrupt here.
 106   1        if( (!((buf[0] == 0x21) && (buf[1] == 0x20) && (buf[6] == 0x07))) && (!((buf[0] == 0x21) &&  (buf[1] == 0
             -x01))) 
 107   1              && (!( (buf[0] == 0x21) && (buf[1] == 0xFF) && (buf[2] == 0x00) && (buf[6] != 0) ) ) )
 108   1        {
 109   2          XBYTE[0xFCB2] |= 0x01;   //restore EP0
 110   2        }       
 111   1      
 112   1        XBYTE[0xFC34] = 0x2C; //bit3:EP read   bit2:flush
C51 COMPILER V9.00   USBAPI                                                                01/16/2014 17:12:00 PAGE 3   

 113   1      
 114   1          // During the FIFO flush operation, if bus reset or detach occur, return immediately.
 115   1        while( XBYTE[0xFC34] & 0x04 ){
 116   2          if( BusReset || (XBYTE[0xFC01] & 0x80 == 0)){
 117   3            return 0;
 118   3          }
 119   2        }
 120   1      
 121   1          return( TRUE );
 122   1      }
 123          
 124          
 125          // Endpoint 0 FIFO Write
 126          unsigned char ctrlFIFOWrite(  unsigned int len, unsigned char *buf )
 127          {
 128   1        unsigned int i,j = 0;
 129   1        
 130   1        while( XBYTE[0xFC34] & 0x04 ){
 131   2          if( BusReset || (XBYTE[0xFC01] & 0x80 == 0)){
 132   3            return 0;
 133   3          }
 134   2        } 
 135   1        
 136   1        while ( len > 64 ){
 137   2          for ( i = 0; i < 64; i++ ){ 
 138   3            XBYTE[0xF000 + i] = buf[j++]; 
 139   3          }
 140   2            
 141   2          len -= 64;
 142   2      
 143   2          // check whether the FIFO is empty or not
 144   2          while( (XBYTE[0xFC37] & 0x20) == 0 ){
 145   3            if( BusReset || (XBYTE[0xFC01] & 0x80 == 0)){
 146   4              return 0;
 147   4            }     
 148   3          }
 149   2        }
 150   1        
 151   1        for ( i = 0; i < len; i++ ) { 
 152   2          XBYTE[0xF000 + i] = buf[j++]; 
 153   2        }
 154   1      
 155   1        XBYTE[0xFC34] = 0x21;
 156   1      
 157   1        return( TRUE );
 158   1      }
 159          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    523    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
